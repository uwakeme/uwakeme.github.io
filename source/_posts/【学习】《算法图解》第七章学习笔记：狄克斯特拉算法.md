---
title: 【学习】《算法图解》第七章学习笔记：狄克斯特拉算法
categories: 学习
tags:
  - 算法
  - 算法图解
  - Dijkstra算法
  - 图算法
  - 最短路径
  - 加权图
  - 权重
---

# 前言

在上一章，我们学习了广度优先搜索（BFS），它能够帮助我们找到两个节点之间的"最短路径"（指段数最少）。但如果路径的每段都有不同的"成本"或"重量"（例如时间、距离、费用），BFS就无能为力了。《算法图解》第七章引入了**狄克斯特拉算法 (Dijkstra's Algorithm)**，这是一种经典的算法，用于解决在**带权图 (Weighted Graph)** 中找到从单一源点到所有其他顶点的最短路径问题，前提是图中所有边的权重都是非负的。

# 一、回顾与问题引出

想象一下，从你家到某个目的地有多条公交线路。BFS可能会告诉你换乘次数最少的线路，但这条线路可能因为绕路或等待时间长而耗时最久。我们真正想要的可能是耗时最短的线路。这时，每段路程的"耗时"就是权重，我们需要一种能处理这些权重的算法。

*   **广度优先搜索 (BFS)**：在非加权图中找出段数最少的路径。
*   **狄克斯特拉算法**：在加权图中（权重为正）找出总权重最小的路径。

# 二、狄克斯特拉算法详解

狄克斯特拉算法由荷兰计算机科学家艾兹赫尔·狄克斯特拉在1956年构思并于1959年发表。它是一种贪心算法，在每一步都选择当前看起来最优的决策。

## （一）适用场景

*   **加权图 (Weighted Graph)**：图中的每条边都有一个关联的数值，称为权重 (Weight)。
*   **非负权重**：狄克斯特拉算法的标准版本要求所有边的权重都必须是正数或零。它不能正确处理带有负权重边的图（特别是负权环）。
*   通常用于有向无环图 (DAG)，或者边权重均为正的有向/无向图。

## （二）核心思想与目标

算法的核心思想是从起始节点开始，逐步扩展到图中的其他节点。对于每个访问到的节点，它会计算从起始节点到该节点的最短路径，并不断更新这个值，直到找到到所有节点（或特定目标节点）的最短路径。

## （三）算法的四个关键步骤（《算法图解》版）

1.  **找出"最便宜"的节点**：在所有未处理的节点中，找到一个从起点出发开销最小（即当前已知路径权重最小）的节点。称之为当前节点。
2.  **更新当前节点的邻居的开销**：对于当前节点的每一个邻居：
    *   计算从起点经过当前节点到达该邻居的总开销。
    *   如果这个新计算出的开销小于之前记录的到达该邻居的开销，则更新该邻居的开销，并将该邻居的"父节点"设置为当前节点（表示我们通过当前节点到达该邻居是目前的最优路径）。
3.  **标记当前节点为已处理**：将当前节点加入"已处理"列表，之后不再重新处理它。因为我们已经找到了从起点到当前节点的最短路径。
4.  **重复**：回到步骤1，直到所有节点都被处理完毕，或者目标节点已经被处理（如果只是找特定终点的最短路径）。

最后，可以通过父节点信息从终点回溯到起点，从而得到完整的具体路径。

# 三、图的表示与辅助数据结构

为了实现狄克斯特拉算法，我们通常需要以下数据结构：

## （一）图的表示 (graph)

使用散列表（Python中的字典）来表示图。外层字典的键是节点，值是另一个散列表，这个内层散列表的键是当前节点的邻居，值是连接这两个节点的边的权重。

```python
# 示例图
graph = {}
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2

graph["a"] = {}
graph["a"]["fin"] = 1

graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5

graph["fin"] = {} # 终点没有邻居
```

## （二）开销表 (costs)

一个散列表，用于存储从起点到各个节点的当前已知的最小开销（总权重）。初始时，起点的开销为0，直接与起点相连的节点的开销是其边的权重，其他节点的开销设为无穷大（表示尚未找到路径）。

```python
infinity = float("inf")
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity
```

## （三）父节点表 (parents)

一个散列表，用于记录在找到的最短路径中，到达每个节点的前一个节点是什么。这对于最后回溯并重建最短路径至关重要。初始时，起点的邻居的父节点是起点，其他节点的父节点可以设为 None。

```python
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None
```

## （四）已处理节点列表 (processed)

一个列表或集合，用于存放已经被处理过的节点。算法不会再次处理这些节点，因为到它们的最短路径已经被确定。

```python
processed = []
```

# 四、Python 代码实现示例

以下是《算法图解》中狄克斯特拉算法的一个Python实现：

```python
# 图的表示 (同上)
graph = {}
graph["start"] = {}
graph["start"]["a"] = 6
graph["start"]["b"] = 2
graph["a"] = {}
graph["a"]["fin"] = 1
graph["b"] = {}
graph["b"]["a"] = 3
graph["b"]["fin"] = 5
graph["fin"] = {}

# 开销表 (同上)
infinity = float("inf")
costs = {}
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity

# 父节点表 (同上)
parents = {}
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = None

# 已处理节点列表
processed = []

def find_lowest_cost_node(costs_table):
    """找出开销表中开销最低且未被处理过的节点"""
    lowest_cost = float("inf")
    lowest_cost_node = None
    for node in costs_table: # 遍历所有节点
        cost = costs_table[node]
        if cost < lowest_cost and node not in processed: # 如果开销更低且未处理
            lowest_cost = cost
            lowest_cost_node = node
    return lowest_cost_node

# 算法主体
node = find_lowest_cost_node(costs) # 1. 初始时，找出最便宜的节点

while node is not None: # 当还有未处理的节点时循环
    cost_to_reach_node = costs[node]
    neighbors = graph[node]
    for n in neighbors.keys(): # 遍历当前节点的所有邻居
        new_cost_to_reach_neighbor = cost_to_reach_node + neighbors[n]
        if costs[n] > new_cost_to_reach_neighbor: # 2. 如果经当前节点前往该邻居更近
            costs[n] = new_cost_to_reach_neighbor # 更新该邻居的开销
            parents[n] = node # 同时将该邻居的父节点设置为当前节点
    processed.append(node) # 3. 将当前节点标记为已处理
    node = find_lowest_cost_node(costs) # 4. 找出接下来要处理的节点，并循环

print("从起点到各节点的最低开销:")
print(costs)

# 打印到终点的路径
path = ["fin"]
current = "fin"
while current != "start":
    if current in parents and parents[current] is not None:
        path.append(parents[current])
        current = parents[current]
    else:
        print(f"无法从{path[-1]}回溯到start")
        break
path.reverse()
print("到终点的最短路径:")
print(path)
```

# 五、负权重边的问题

## （一）为什么狄克斯特拉算法不适用于负权重边

狄克斯特拉算法的核心贪心策略是：一旦一个节点被标记为"已处理"，就意味着从起点到该节点的最短路径已经被找到，并且不会再有更短的路径。这个假设在所有权重都为正时成立。

然而，如果存在负权重边，情况就变了：

*   **可能存在更短的路径**：一条负权重边可能会使得一条包含更多段的路径，其总权重反而比之前找到的"最短"路径还要小。算法在处理完一个节点后，可能因为后续经过一个负权重边，导致之前已处理节点的路径可以被进一步缩短，这就违背了算法的基本假设。
*   **负权环 (Negative Cycle)**：如果图中存在总权重为负的环路，那么理论上的"最短路径"将是无限小（通过不断绕环），算法会陷入无限循环或给出错误结果。

## （二）贝尔曼-福德算法 (Bellman-Ford algorithm)

对于包含负权重边的图（但没有负权环），可以使用**贝尔曼-福德算法**来找到最短路径。如果图中存在负权环，贝尔曼-福德算法可以检测到这种情况。本书不详细介绍此算法。

# 六、总结

狄克斯特拉算法是解决单源最短路径问题的强大工具，特别适用于权重为正的加权图。

*   **与BFS对比**：BFS 用于非加权图，找段数最少的路径；狄克斯特拉用于加权图，找总权重最小的路径。
*   **核心步骤**：迭代选择开销最小的未处理节点，更新其邻居的开销和父节点，标记为已处理。
*   **数据结构**：依赖图、开销表、父节点表和已处理列表。
*   **局限性**：不能处理负权重边，特别是负权环。若有负权重边，需考虑贝尔曼-福德算法。

理解狄克斯特拉算法对于掌握更复杂的图算法和网络路由协议等具有重要意义。

# 七、参考资料

- 《算法图解》（Grokking Algorithms）by Aditya Y. Bhargava
- [《算法图解》学习笔记（七）：狄克斯特拉算法（附代码） - CSDN博客](https://blog.csdn.net/TeFuirnever/article/details/100746214)
- [[笔记]《算法图解》第七章狄克斯特拉算法 - bingo彬哥 - 博客园](https://www.cnblogs.com/everfight/p/grokking_algorithms_note_7.html)
- [Chapter 7. Dijkstra's algorithm · Grokking Algorithms - Manning Publications](https://livebook.manning.com/book/grokking-algorithms/chapter-7/1) 