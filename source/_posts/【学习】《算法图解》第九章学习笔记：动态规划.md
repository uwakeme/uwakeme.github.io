---
title: 【学习】《算法图解》第九章学习笔记：动态规划
categories: 学习
tags:
  - 算法
  - 算法图解
  - 动态规划
  - DP
  - 最优化问题
  - 子问题
  - 背包问题
  - 最长公共子序列
---

# 前言

当我们遇到一些看似棘手，需要在特定约束条件下找到最优方案的问题时，动态规划 (Dynamic Programming, DP) 往往能提供强大的解决思路。《算法图解》第九章深入浅出地介绍了这一重要算法范式。动态规划的核心在于将复杂问题分解为更小的、可管理的子问题，并通过解决这些子问题来逐步构建出原问题的最优解，同时避免了重复计算，确保了效率和最优性。

# 一、什么是动态规划 (Dynamic Programming, DP)

## （一）核心思想

动态规划是一种通过将原问题分解为相对简单的**子问题**来求解复杂问题的方法。它通常用于优化问题，即寻找具有最优属性（例如最大值、最小值、最短路径等）的解。

其基本思想是：
1.  **分解问题**：将原始问题分解成一系列相互关联的子问题。
2.  **解决子问题**：从最小的子问题开始，逐步解决它们。
3.  **存储子问题解**：将子问题的解存储起来（通常在一个表格或数组中），以便后续需要时可以直接使用，避免重复计算。这被称为"记忆化"或"表格法"。
4.  **构建原问题解**：基于已解决的子问题的解，逐步构建出更大子问题的解，直至得到原问题的解。

## （二）与分而治之、贪婪算法的比较

| 特性         | 分而治之 (Divide and Conquer)      | 贪婪算法 (Greedy Algorithm)        | 动态规划 (Dynamic Programming)          |
|--------------|-----------------------------------|------------------------------------|-----------------------------------------|
| **子问题**   | 通常相互独立                      | 每步选择一个局部最优，不一定考虑子问题 | 子问题可能重叠，且最优解依赖于子问题最优解 |
| **选择策略** | 解决所有子问题后合并              | 每步做出当前最优选择，不回溯         | 通过解决所有相关子问题，做出全局最优选择 |
| **最优性**   | 依赖于问题本身                    | 不一定能得到全局最优解             | 通常能得到全局最优解                   |
| **主要用途** | 排序（快排、归并）、查找（二分）等  | 寻找近似解或某些特定问题的最优解     | 最优化问题（如背包、最短路径、序列对齐） |

动态规划的关键在于它能巧妙处理**重叠子问题 (Overlapping Subproblems)** 和具有**最优子结构 (Optimal Substructure)** 的问题。

# 二、动态规划的关键要素

## （一）最优子结构

一个问题如果其最优解包含了其子问题的最优解，那么称这个问题具有最优子结构。这是动态规划能够适用的前提之一。例如，如果到城市X的最短路径经过城市Y，那么从起点到城市Y的这段路径也必须是从起点到Y的最短路径。

## （二）重叠子问题

在递归地解决问题的过程中，如果某些相同的子问题被反复计算多次，那么称该问题具有重叠子问题。动态规划通过存储这些子问题的解（通常在一个表格中，这个表格常被称为DP表），当再次需要解决这个子问题时，直接查表获取结果，而不是重新计算，从而大大提高了效率。

# 三、解决动态规划问题的步骤（以背包问题为例）

《算法图解》中常使用**网格（或表格）**来可视化和解决动态规划问题。以下是一般的步骤：

## （一）识别子问题

思考如何将大问题分解成规模更小但结构相似的子问题。对于背包问题，子问题可以是："在只考虑前 `i` 件物品，且背包容量限制为 `j` 的情况下，能够获得的最大价值是多少？"

## （二）定义状态（构建网格/表格）

状态是描述子问题的特定参数。在网格中：
*   **行 (rows)**：通常代表问题的一个维度，例如可供选择的物品（从第1件到第 `i` 件）。
*   **列 (columns)**：通常代表问题的另一个维度，例如背包的容量（从1到最大容量 `W`）。
*   **单元格 `dp[i][j]`**：存储对应子问题的最优解。例如，`dp[i][j]` 表示在前 `i` 件物品中选择，放入容量为 `j` 的背包能获得的最大价值。

## （三）找出状态转移方程

这是动态规划的核心，它定义了如何从一个或多个较小子问题的解（已填充的表格单元）计算出当前子问题的解。对于0/1背包问题（每件物品要么选，要么不选）：

设 `dp[i][j]` 为考虑前 `i` 件物品，背包容量为 `j` 时的最大价值。
设 `value[i]` 为第 `i` 件物品的价值，`weight[i]` 为第 `i` 件物品的重量。

对于单元格 `dp[i][j]`，有两种选择：
1.  **不放入第 `i` 件物品**：那么最大价值与只考虑前 `i-1` 件物品在容量 `j` 下的最大价值相同，即 `dp[i-1][j]`。
2.  **放入第 `i` 件物品**（前提是当前背包容量 `j` 必须大于或等于 `weight[i]`）：那么价值是第 `i` 件物品的价值 `value[i]` 加上将剩余容量 `j - weight[i]` 用于装前 `i-1` 件物品所能获得的最大价值，即 `value[i] + dp[i-1][j - weight[i]]`。

状态转移方程为：
`dp[i][j] = max(dp[i-1][j], value[i] + dp[i-1][j - weight[i]])`  (当 `j >= weight[i]` 时)
`dp[i][j] = dp[i-1][j]` (当 `j < weight[i]` 时，即装不下第i件物品)

## （四）填充表格（自底向上）

通常从表格的初始状态（例如 `dp[0][...]` 或 `dp[...][0]`，通常为0）开始，按照行或列的顺序，利用状态转移方程逐个计算并填充表格中的每个单元格。最终，表格右下角的单元格（或某个特定单元格）通常就包含了原问题的最优解。

## （五）回溯找到最优解的具体构成（如果需要）

一旦填充完DP表并且找到了最优值，有时还需要知道这个最优解是如何构成的（例如，背包里具体装了哪些物品）。这通常可以通过从最优解所在的单元格开始，根据状态转移方程反向追溯，判断每一步是如何达到当前最优状态的。

# 四、经典示例：0/1 背包问题

## （一）问题描述

你是一个小偷，有一个容量为 `W` 的背包。有 `N` 件物品，每件物品 `i` 有一个重量 `weight[i]` 和一个价值 `value[i]`。目标是选择一部分物品放入背包，使得物品总重量不超过背包容量 `W`，且总价值最大。

## （二）使用动态规划的网格化解决方案

1.  **创建网格**：行代表物品 (0 to N)，列代表背包容量 (0 to W)。`dp[i][j]` 代表考虑前 `i` 件物品，在容量为 `j` 的背包下的最大价值。
2.  **初始化**：`dp[0][j] = 0` for all `j` (不选任何物品，价值为0)。`dp[i][0] = 0` for all `i` (背包容量为0，价值为0)。
3.  **填充网格**：遍历物品 `i` 从 1 到 `N`，遍历容量 `j` 从 1 到 `W`：
    *   如果 `weight[i-1] <= j` (第 `i` 件物品可以放入，注意索引通常从0开始，所以用`i-1`表示第i件物品)：
        `dp[i][j] = max(dp[i-1][j], value[i-1] + dp[i-1][j - weight[i-1]])`
    *   否则 (第 `i` 件物品放不下)：
        `dp[i][j] = dp[i-1][j]`
4.  **结果**：`dp[N][W]` 就是最终的最大价值。

## （三）Python 代码示例

```python
def knapsack_dp(values, weights, capacity):
    n = len(values)
    # 创建DP表，dp[i][w] 表示在前i个物品中选择，背包容量为w时的最大价值
    # 行数n+1 (0到n)，列数capacity+1 (0到capacity)
    dp = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)]

    # 填充DP表
    for i in range(1, n + 1): # 遍历物品 (第i个物品，对应索引i-1)
        for w in range(1, capacity + 1): # 遍历背包容量
            # 当前物品的重量和价值 (注意values和weights是0索引的)
            current_weight = weights[i-1]
            current_value = values[i-1]

            if current_weight <= w: # 如果当前物品可以放入背包
                # 选择放入当前物品 vs 不放入当前物品
                dp[i][w] = max(dp[i-1][w],  # 不放入
                               current_value + dp[i-1][w - current_weight]) # 放入
            else: # 当前物品放不下
                dp[i][w] = dp[i-1][w]
    
    # --- (可选) 回溯找出选择了哪些物品 ---
    selected_items_indices = []
    total_value = dp[n][capacity]
    remaining_capacity = capacity
    for i in range(n, 0, -1):
        if total_value <= 0: break
        # 如果当前价值不等于上一行同容量的价值，说明当前物品被选中了
        if total_value != dp[i-1][remaining_capacity]:
            selected_items_indices.append(i-1) # 添加物品索引
            total_value -= values[i-1]
            remaining_capacity -= weights[i-1]
    selected_items_indices.reverse()
    # --- 回溯结束 ---

    return dp[n][capacity], selected_items_indices

# 示例
values = [1500, 3000, 2000] # 对应 吉他、音响、笔记本电脑 (《算法图解》例子)
weights = [1, 4, 3]
capacity = 4

max_value, items_selected = knapsack_dp(values, weights, capacity)
print(f"最大价值: {max_value}") # 输出应为 3500 (吉他+笔记本电脑)
print(f"选择的物品索引: {items_selected}") # 输出应类似 [0, 2]

# 另一个书中的例子: 野营物品
# items = {"水": (3, 10), "书": (1, 3), "食物": (2, 9), "夹克": (2, 5), "相机": (1, 6)}
# values_camp = [10, 3, 9, 5, 6]
# weights_camp = [3, 1, 2, 2, 1]
# capacity_camp = 6
# max_value_camp, items_selected_camp = knapsack_dp(values_camp, weights_camp, capacity_camp)
# print(f"野营最大价值: {max_value_camp}") # 应为 25 (水、食物、相机)
# print(f"野营选择的物品索引: {items_selected_camp}")
```

# 五、其他动态规划应用

动态规划的应用非常广泛，除了背包问题，还包括：

*   **最长公共子串 (Longest Common Substring)**：找出两个字符串中都包含的最长连续子串。
*   **最长公共子序列 (Longest Common Subsequence, LCS)**：找出两个序列中都以相同顺序出现的、但不一定连续的最长子序列。生物学家用它来比较DNA序列的相似性，`git diff`也用类似原理比较文件差异。
*   **编辑距离 (Levenshtein Distance)**：衡量两个字符串之间的相似度，即从一个字符串转换成另一个字符串所需的最少单字符编辑（插入、删除或替换）次数。用于拼写检查、抄袭检测等。
*   **矩阵链乘法**：确定一组矩阵相乘的最佳顺序（以最小化标量乘法次数）。
*   **最优二叉搜索树**：构建查找成本最低的二叉搜索树。
*   **文本对齐/断行**：在文字处理软件中，为使每行长度尽可能一致而智能地决定断行位置。

# 六、动态规划的启示与总结

*   **适用条件**：动态规划非常适用于那些需要在给定约束条件下**优化某个指标**（最大化或最小化），并且问题能够被分解为**离散的、重叠的子问题**，且具有**最优子结构**的场景。
*   **网格化思考**：几乎所有的动态规划问题都可以通过构建一个网格（DP表）来辅助思考和求解。网格的维度对应问题的状态，单元格的值对应子问题的解。
*   **子问题定义是关键**：如何清晰地定义子问题以及网格中每个单元格的含义，是成功应用DP的第一步。
*   **状态转移方程是核心**：找到正确的状态转移方程，即如何从子问题的解推导出当前问题的解，是DP算法的核心。
*   **没有通用公式**："没有放之四海皆准的计算动态规划解决方案的公式。" 每个问题都需要仔细分析其结构，设计独特的DP表和状态转移方程。
*   **处理依赖性**：仅当子问题是离散的（不相互依赖形成循环或复杂约束）时，DP才有效。如果子问题间有复杂的依赖关系（例如，选择A的前提是必须选择B，而选择B又影响A的价值），标准DP可能不适用或需要更复杂的模型。

动态规划是一种强大的思维工具和算法技术，掌握它能帮助我们解决许多看起来非常棘手的优化问题。

# 七、参考资料

- 《算法图解》（Grokking Algorithms）by Aditya Y. Bhargava
- [《算法图解》第九章 动态规划 - CSDN博客](https://blog.csdn.net/weixin_38313518/article/details/78548464)
- [[笔记]《算法图解》第九章动态规划 - bingo彬哥 - 博客园](https://www.cnblogs.com/everfight/p/grokking_algorithms_note_9.html)
- [Chapter 9. Dynamic programming · Grokking Algorithms - Manning Publications](https://livebook.manning.com/book/grokking-algorithms/chapter-9/ch09) 