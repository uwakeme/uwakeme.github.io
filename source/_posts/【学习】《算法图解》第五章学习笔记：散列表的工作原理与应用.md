---
title: 【学习】《算法图解》第五章学习笔记：散列表的工作原理与应用
categories: 学习
tags:
  - 算法
  - 算法图解
  - 散列表
  - 哈希表
  - 字典
  - 散列函数
  - 冲突解决
  - 数据结构
---

# 前言

《算法图解》第五章为我们介绍了计算机科学中一种极为重要且应用广泛的数据结构——**散列表（Hash Table）**，在 Python 中我们更熟悉它的名字：**字典（Dictionary）**。散列表以其惊人的平均 O(1) 时间复杂度进行查找、插入和删除操作而闻名，使其成为许多高效算法和系统的基石。本篇笔记将深入探讨散列表的内部工作机制，包括核心的散列函数、如何处理不可避免的冲突，以及影响其性能的关键因素和常见应用场景。

# 一、散列函数 (Hash Functions)

散列函数是散列表的心脏。简单来说，散列函数是一个特殊的函数，它接收任意大小的输入数据（称为"键"或"Key"），并将其转换为一个固定大小的数字，这个数字通常用作数组的索引。

## （一）散列函数的主要特性

一个好的散列函数应具备以下关键特性：

1.  **一致性 (Consistent)**：对于相同的输入键，散列函数必须始终返回相同的输出（散列值/索引）。如果输入 'apple' 得到索引 3，那么每次输入 'apple' 都应该得到 3。
2.  **良好的映射性 (Good Distribution)**：理想情况下，散列函数应将不同的输入键尽可能均匀地映射到不同的输出索引上。如果所有键都映射到同一个索引，散列表的效率将大大降低。
3.  **范围有效性 (Valid Index Range)**：散列函数必须知道其输出索引的有效范围（即散列表底层数组的大小），并且只返回该范围内的索引。

例如，一个简单的散列函数可能是将字符串中每个字符的 ASCII 值相加，然后对数组的大小取模。Python 的内置 `hash()` 函数就是一个更复杂的例子。

# 二、散列表 (Hash Tables) / 字典 (Dictionaries)

散列表是一种巧妙地结合了散列函数和数组（或其他类似线性结构）的数据结构。其基本工作流程如下：

1.  当要存储一个键值对（例如，商品名和价格）时，首先将键（商品名）传递给散列函数。
2.  散列函数计算出一个索引。
3.  该键值对就存储在数组对应索引的位置（称为"桶"或"槽"）。

在 Python 中，我们日常使用的**字典 (`dict`)** 就是散列表的一种高效实现。

## （一）Python 字典示例

```python
# 创建一个空字典 (散列表)
phone_book = {}
# 或者使用 dict()
# phone_book = dict()

# 添加键值对 (模拟电话簿)
phone_book["jenny"] = 8675309
phone_book["emergency"] = 911
phone_book["alice"] = 1234567

print(f"电话簿内容: {phone_book}")

# 查找操作 (O(1) 平均时间)
print(f"Jenny的电话号码是: {phone_book['jenny']}")

# 检查键是否存在
if "bob" in phone_book:
    print(f"Bob的电话号码是: {phone_book['bob']}")
else:
    print("电话簿中没有Bob的记录")

# 删除操作
if "alice" in phone_book:
    del phone_book["alice"]
    print(f"删除Alice后的电话簿: {phone_book}")
```

# 三、冲突 (Collisions)

散列函数的目标是将不同的键映射到不同的索引，但由于键的可能数量通常远大于数组槽位的数量（鸽巢原理），不可避免地会出现**冲突 (Collision)**：即两个或多个不同的键被散列函数映射到了同一个索引位置。

例如，假设我们的散列函数是 `hash(key) = len(key) % 5`，并且数组大小为5。
*   `hash("apple") = 5 % 5 = 0`
*   `hash("grape") = 5 % 5 = 0`

此时，"apple" 和 "grape" 都想存储在索引 0 的位置，就发生了冲突。

## （一）处理冲突：链表法 (Separate Chaining)

《算法图解》中介绍的处理冲突的主要方法是**链表法**。其思想是：在散列表的每个槽位上，不再直接存储单个键值对，而是存储一个指向链表的指针（或链表本身）。所有散列到该槽位的键值对都存储在这个链表中。

*   **插入**：计算键的散列值找到对应槽位。如果槽位为空，创建一个新链表并添加键值对；如果槽位已有链表，则将新键值对添加到链表的末尾（或头部）。
*   **查找**：计算键的散列值找到对应槽位。然后遍历该槽位上的链表，直到找到匹配的键。
*   **删除**：计算键的散列值找到对应槽位。然后遍历链表，找到并删除匹配的键值对。

如果散列函数设计良好且填装因子较低，这些链表通常会很短，使得操作仍然接近 O(1)。

```mermaid
graph TD
    subgraph 散列表 (数组)
        direction LR
        A[槽位 0] --> L0["链表: (apple, $0.67) --> (grape, $1.20) --> null"]
        B[槽位 1] --> L1["链表: (milk, $1.49) --> null"]
        C[槽位 2] --> L2["空"]
        D[槽位 3] --> L3["链表: (avocado, $1.75) --> null"]
        E[槽位 4] --> L4["空"]
    end
    K1["键: 'apple'"] --> HF["hash('apple') % 5 = 0"]
    K2["键: 'grape'"] --> HF2["hash('grape') % 5 = 0"]
    K3["键: 'milk'"] --> HF3["hash('milk') % 5 = 1"]
    K4["键: 'avocado'"] --> HF4["hash('avocado') % 5 = 3"]
    HF --> A
    HF2 --> A
    HF3 --> B
    HF4 --> D
```

# 四、性能分析与优化

散列表的卓越性能并非无条件的，它依赖于冲突的有效管理和良好的设计。

## （一）时间复杂度

*   **平均情况**：对于查找、插入和删除操作，散列表的平均时间复杂度都是 **O(1)**。这是因为理想情况下，散列函数能将键均匀分布，且链表长度很短。
*   **最坏情况**：如果散列函数设计极差，或者所有键都恰好冲突（例如，所有键都映射到同一个槽位），那么所有操作都将退化为对链表的线性搜索，时间复杂度变为 **O(n)**，其中 n 是散列表中的元素数量。这种情况下的散列表性能还不如有序数组的二分查找。

## （二）优化手段

为了保持 O(1) 的平均性能并避免最坏情况，主要依赖以下两点：

1.  **较低的填装因子 (Load Factor)**
    *   **定义**：填装因子 = （散列表中存储的元素数量） / （散列表的总槽位数）。
    *   **作用**：它衡量了散列表的"满载"程度。填装因子越高，新元素插入时发生冲突的概率就越大，链表就可能越长。
    *   **调整长度 (Resizing)**：当填装因子超过一个预设的阈值（例如，《算法图解》中建议的经验规则是 0.7 或 70%），散列表就需要进行**扩容**。扩容意味着创建一个更大的新数组，并将旧数组中的所有元素通过新的（可能调整过的）散列函数重新散列到新数组中。这个过程虽然本身耗时，但它能确保填装因子保持在较低水平，从而维持后续操作的 O(1) 平均性能。

2.  **良好的散列函数**
    *   **特点**：一个良好的散列函数应尽可能地将键**均匀地**分布到所有可用的槽位上。如果键的分布不均，某些槽位会变得非常拥挤（长链表），而其他槽位则可能空着，这会降低整体性能。
    *   加密散列函数（如 SHA）虽然不是为通用散列表设计的，但它们具有很好的分布特性。实际中，编程语言内置的散列函数会经过精心设计和测试以达到良好的性能。

# 五、散列表的应用案例

散列表因其高效性，在各种应用中都扮演着核心角色：

1.  **模拟映射关系**：
    *   电话簿：将姓名映射到电话号码。
    *   DNS 解析：将域名（如 `www.google.com`）映射到 IP 地址。
    *   Python 字典本身就是最直接的映射关系应用。

    ```python
    # 商品价格查询
    price_list = {
        "apple": 0.67,
        "milk": 1.49,
        "avocado": 1.75
    }
    print(f"牛奶的价格是: ${price_list.get('milk')}")
    ```

2.  **防止重复**：
    *   在线投票系统：用散列表记录已投票的用户，当用户尝试再次投票时，可以快速检查其是否已存在于散列表中。

    ```python
    voted = {}
    def check_voter(name):
        if voted.get(name):
            print(f"{name}，你已经投过票了，请勿重复投票！")
        else:
            voted[name] = True
            print(f"{name}，感谢您的投票！")

    check_voter("Tom")
    check_voter("Mike")
    check_voter("Tom")
    ```

3.  **缓存数据 (Caching)**：
    *   Web 服务器或应用程序经常使用散列表作为缓存。当一个请求需要昂贵的计算或数据库查询时，可以将结果存储在散列表中（以请求参数或某种唯一标识为键）。下次相同的请求到来时，可以直接从缓存中快速获取结果，而无需重新计算。

    ```python
    cache = {}
    def get_data_from_server(url):
        # 模拟从服务器获取数据，这是一个耗时操作
        print(f"正在从服务器获取 {url} 的数据...")
        import time
        time.sleep(2) # 模拟网络延迟
        data = f"来自 {url} 的页面内容"
        return data

    def get_page(url):
        if cache.get(url):
            print(f"从缓存中获取 {url}...")
            return cache[url]
        else:
            data = get_data_from_server(url)
            cache[url] = data # 将结果存入缓存
            return data

    print(get_page("https://example.com/page1"))
    print(get_page("https://example.com/page1")) # 第二次访问将从缓存获取
    ```

# 六、总结

散列表（哈希表/字典）是一种极其强大的数据结构，它通过散列函数将键映射到数组索引，从而实现平均 O(1) 时间的查找、插入和删除操作。理解散列函数的重要性、冲突的不可避免性以及如何通过链表法等策略解决冲突是掌握散列表的关键。同时，维持较低的填装因子（通过适时扩容）和使用良好的散列函数是确保其高效性能的两个核心要素。散列表在模拟映射、防止重复和数据缓存等众多场景下都有着不可替代的作用。

# 七、参考资料

-   《算法图解》 （Grokking Algorithms） by Aditya Y. Bhargava
-   [《算法图解》第五章散列函数和散列表 - CSDN博客](https://blog.csdn.net/weixin_38313518/article/details/78522085)
-   [《算法图解》第五章散列表学习心得 - CSDN博客](https://blog.csdn.net/sysu63/article/details/79764008)
-   [《图解算法》第5章散列表 - 腾讯云开发者社区](https://cloud.tencent.com/developer/article/1678642)
-   [6.1 哈希表 - Hello 算法](https://www.hello-algo.com/chapter_hashing/hash_map/) 