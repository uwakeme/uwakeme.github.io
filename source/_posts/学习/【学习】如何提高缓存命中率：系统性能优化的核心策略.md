---
title: ã€å­¦ä¹ ã€‘å¦‚ä½•æé«˜ç¼“å­˜å‘½ä¸­ç‡ï¼šç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒç­–ç•¥
categories: å­¦ä¹ 
date: 2025-08-15
tags:
  - ç¼“å­˜
  - æ€§èƒ½ä¼˜åŒ–
  - Redis
  - ç³»ç»Ÿæ¶æ„
  - åˆ†å¸ƒå¼ç³»ç»Ÿ
---

# ä¸€ã€ç¼“å­˜å‘½ä¸­ç‡æ¦‚è¿°

## ï¼ˆä¸€ï¼‰ä»€ä¹ˆæ˜¯ç¼“å­˜å‘½ä¸­ç‡

ç¼“å­˜å‘½ä¸­ç‡ï¼ˆCache Hit Rateï¼‰æ˜¯è¡¡é‡ç¼“å­˜ç³»ç»Ÿæ€§èƒ½çš„æ ¸å¿ƒæŒ‡æ ‡ï¼Œè¡¨ç¤ºä»ç¼“å­˜ä¸­æˆåŠŸè·å–æ•°æ®çš„è¯·æ±‚å æ€»è¯·æ±‚æ•°çš„æ¯”ä¾‹ã€‚

```javascript
// ç¼“å­˜å‘½ä¸­ç‡è®¡ç®—å…¬å¼
const cacheHitRate = (cacheHits / totalRequests) * 100;

// ç¤ºä¾‹ï¼šç¼“å­˜å‘½ä¸­ç‡ç›‘æ§
class CacheMetrics {
    constructor() {
        this.hits = 0;      // ç¼“å­˜å‘½ä¸­æ¬¡æ•°
        this.misses = 0;    // ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°
        this.total = 0;     // æ€»è¯·æ±‚æ¬¡æ•°
    }
    
    // è®°å½•ç¼“å­˜å‘½ä¸­
    recordHit() {
        this.hits++;
        this.total++;
    }
    
    // è®°å½•ç¼“å­˜æœªå‘½ä¸­
    recordMiss() {
        this.misses++;
        this.total++;
    }
    
    // è®¡ç®—å‘½ä¸­ç‡
    getHitRate() {
        return this.total > 0 ? (this.hits / this.total * 100).toFixed(2) : 0;
    }
    
    // è·å–ç»Ÿè®¡ä¿¡æ¯
    getStats() {
        return {
            hitRate: this.getHitRate() + '%',
            hits: this.hits,
            misses: this.misses,
            total: this.total
        };
    }
}
```

## ï¼ˆäºŒï¼‰ç¼“å­˜å‘½ä¸­ç‡çš„é‡è¦æ€§

**æ€§èƒ½å½±å“ï¼š**
- é«˜å‘½ä¸­ç‡ï¼šå‡å°‘æ•°æ®åº“è®¿é—®ï¼Œæå‡å“åº”é€Ÿåº¦
- ä½å‘½ä¸­ç‡ï¼šé¢‘ç¹è®¿é—®åç«¯å­˜å‚¨ï¼Œå¢åŠ ç³»ç»Ÿè´Ÿè½½
- æˆæœ¬æ•ˆç›Šï¼šå‡å°‘ç¡¬ä»¶èµ„æºæ¶ˆè€—ï¼Œé™ä½è¿è¥æˆæœ¬

**ä¸šåŠ¡ä»·å€¼ï¼š**
- ç”¨æˆ·ä½“éªŒï¼šé¡µé¢åŠ è½½é€Ÿåº¦æå‡ï¼Œç”¨æˆ·æ»¡æ„åº¦å¢åŠ 
- ç³»ç»Ÿç¨³å®šæ€§ï¼šå‡å°‘æ•°æ®åº“å‹åŠ›ï¼Œæé«˜ç³»ç»Ÿå¯ç”¨æ€§
- æ‰©å±•æ€§ï¼šæ”¯æŒæ›´é«˜å¹¶å‘è®¿é—®é‡

# äºŒã€ç¼“å­˜ç­–ç•¥ä¼˜åŒ–

## ï¼ˆä¸€ï¼‰ç¼“å­˜æ·˜æ±°ç®—æ³•é€‰æ‹©

### 1. LRUï¼ˆæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰ç®—æ³•

```java
// LRUç¼“å­˜å®ç°ï¼šä¼˜å…ˆæ·˜æ±°æœ€ä¹…æœªä½¿ç”¨çš„æ•°æ®
public class LRUCache<K, V> {
    private final int capacity;
    private final LinkedHashMap<K, V> cache;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        // LinkedHashMapçš„accessOrder=trueè¡¨ç¤ºæŒ‰è®¿é—®é¡ºåºæ’åº
        this.cache = new LinkedHashMap<K, V>(capacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
                return size() > capacity;  // è¶…è¿‡å®¹é‡æ—¶è‡ªåŠ¨åˆ é™¤æœ€è€çš„å…ƒç´ 
            }
        };
    }
    
    // è·å–æ•°æ®ï¼ŒåŒæ—¶æ›´æ–°è®¿é—®é¡ºåº
    public synchronized V get(K key) {
        return cache.get(key);  // LinkedHashMapä¼šè‡ªåŠ¨è°ƒæ•´é¡ºåº
    }
    
    // å­˜å‚¨æ•°æ®
    public synchronized void put(K key, V value) {
        cache.put(key, value);
    }
    
    // è·å–ç¼“å­˜å¤§å°
    public synchronized int size() {
        return cache.size();
    }
}
```

### 2. LFUï¼ˆæœ€å°‘ä½¿ç”¨é¢‘ç‡ï¼‰ç®—æ³•

```java
// LFUç¼“å­˜å®ç°ï¼šä¼˜å…ˆæ·˜æ±°ä½¿ç”¨é¢‘ç‡æœ€ä½çš„æ•°æ®
public class LFUCache<K, V> {
    private final int capacity;
    private final Map<K, V> values;           // å­˜å‚¨é”®å€¼å¯¹
    private final Map<K, Integer> frequencies; // å­˜å‚¨è®¿é—®é¢‘ç‡
    private final Map<Integer, LinkedHashSet<K>> frequencyGroups; // æŒ‰é¢‘ç‡åˆ†ç»„
    private int minFrequency;                 // æœ€å°é¢‘ç‡
    
    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.values = new HashMap<>();
        this.frequencies = new HashMap<>();
        this.frequencyGroups = new HashMap<>();
        this.minFrequency = 1;
    }
    
    public V get(K key) {
        if (!values.containsKey(key)) {
            return null;
        }
        
        // æ›´æ–°è®¿é—®é¢‘ç‡
        updateFrequency(key);
        return values.get(key);
    }
    
    public void put(K key, V value) {
        if (capacity <= 0) return;
        
        if (values.containsKey(key)) {
            values.put(key, value);
            updateFrequency(key);
            return;
        }
        
        // å®¹é‡å·²æ»¡ï¼Œéœ€è¦æ·˜æ±°
        if (values.size() >= capacity) {
            evictLFU();
        }
        
        // æ·»åŠ æ–°å…ƒç´ 
        values.put(key, value);
        frequencies.put(key, 1);
        frequencyGroups.computeIfAbsent(1, k -> new LinkedHashSet<>()).add(key);
        minFrequency = 1;
    }
    
    // æ›´æ–°è®¿é—®é¢‘ç‡
    private void updateFrequency(K key) {
        int oldFreq = frequencies.get(key);
        int newFreq = oldFreq + 1;
        
        frequencies.put(key, newFreq);
        
        // ä»æ—§é¢‘ç‡ç»„ä¸­ç§»é™¤
        frequencyGroups.get(oldFreq).remove(key);
        if (frequencyGroups.get(oldFreq).isEmpty() && oldFreq == minFrequency) {
            minFrequency++;
        }
        
        // æ·»åŠ åˆ°æ–°é¢‘ç‡ç»„
        frequencyGroups.computeIfAbsent(newFreq, k -> new LinkedHashSet<>()).add(key);
    }
    
    // æ·˜æ±°æœ€å°‘ä½¿ç”¨é¢‘ç‡çš„å…ƒç´ 
    private void evictLFU() {
        K keyToEvict = frequencyGroups.get(minFrequency).iterator().next();
        frequencyGroups.get(minFrequency).remove(keyToEvict);
        values.remove(keyToEvict);
        frequencies.remove(keyToEvict);
    }
}
```

## ï¼ˆäºŒï¼‰ç¼“å­˜é¢„çƒ­ç­–ç•¥

### 1. ç³»ç»Ÿå¯åŠ¨é¢„çƒ­

```java
// ç³»ç»Ÿå¯åŠ¨æ—¶é¢„çƒ­çƒ­ç‚¹æ•°æ®
@Component
public class CacheWarmupService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private ProductService productService;
    
    // åº”ç”¨å¯åŠ¨åæ‰§è¡Œé¢„çƒ­
    @PostConstruct
    public void warmupCache() {
        CompletableFuture.runAsync(() -> {
            try {
                warmupHotUsers();      // é¢„çƒ­çƒ­é—¨ç”¨æˆ·æ•°æ®
                warmupHotProducts();   // é¢„çƒ­çƒ­é—¨å•†å“æ•°æ®
                warmupSystemConfig();  // é¢„çƒ­ç³»ç»Ÿé…ç½®æ•°æ®
                
                log.info("ç¼“å­˜é¢„çƒ­å®Œæˆ");
            } catch (Exception e) {
                log.error("ç¼“å­˜é¢„çƒ­å¤±è´¥", e);
            }
        });
    }
    
    // é¢„çƒ­çƒ­é—¨ç”¨æˆ·æ•°æ®
    private void warmupHotUsers() {
        List<Long> hotUserIds = userService.getHotUserIds(1000); // è·å–1000ä¸ªçƒ­é—¨ç”¨æˆ·ID
        
        for (Long userId : hotUserIds) {
            try {
                User user = userService.getUserFromDB(userId);
                if (user != null) {
                    String cacheKey = "user:" + userId;
                    redisTemplate.opsForValue().set(cacheKey, user, Duration.ofHours(2));
                }
            } catch (Exception e) {
                log.warn("é¢„çƒ­ç”¨æˆ·æ•°æ®å¤±è´¥: userId={}", userId, e);
            }
        }
        
        log.info("ç”¨æˆ·æ•°æ®é¢„çƒ­å®Œæˆï¼Œé¢„çƒ­æ•°é‡: {}", hotUserIds.size());
    }
    
    // é¢„çƒ­çƒ­é—¨å•†å“æ•°æ®
    private void warmupHotProducts() {
        List<Long> hotProductIds = productService.getHotProductIds(500);
        
        // ä½¿ç”¨æ‰¹é‡æ“ä½œæé«˜æ•ˆç‡
        Map<String, Object> batchData = new HashMap<>();
        for (Long productId : hotProductIds) {
            try {
                Product product = productService.getProductFromDB(productId);
                if (product != null) {
                    String cacheKey = "product:" + productId;
                    batchData.put(cacheKey, product);
                }
            } catch (Exception e) {
                log.warn("é¢„çƒ­å•†å“æ•°æ®å¤±è´¥: productId={}", productId, e);
            }
        }
        
        // æ‰¹é‡å†™å…¥Redis
        if (!batchData.isEmpty()) {
            redisTemplate.opsForValue().multiSet(batchData);
            // è®¾ç½®è¿‡æœŸæ—¶é—´
            batchData.keySet().forEach(key -> 
                redisTemplate.expire(key, Duration.ofHours(1))
            );
        }
        
        log.info("å•†å“æ•°æ®é¢„çƒ­å®Œæˆï¼Œé¢„çƒ­æ•°é‡: {}", batchData.size());
    }
    
    // é¢„çƒ­ç³»ç»Ÿé…ç½®æ•°æ®
    private void warmupSystemConfig() {
        // ç³»ç»Ÿé…ç½®é€šå¸¸å˜åŒ–è¾ƒå°‘ï¼Œå¯ä»¥è®¾ç½®è¾ƒé•¿çš„è¿‡æœŸæ—¶é—´
        Map<String, Object> configs = systemConfigService.getAllConfigs();
        
        configs.forEach((key, value) -> {
            String cacheKey = "config:" + key;
            redisTemplate.opsForValue().set(cacheKey, value, Duration.ofDays(1));
        });
        
        log.info("ç³»ç»Ÿé…ç½®é¢„çƒ­å®Œæˆï¼Œé…ç½®æ•°é‡: {}", configs.size());
    }
}
```

### 2. å®šæ—¶é¢„çƒ­ä»»åŠ¡

```java
// å®šæ—¶é¢„çƒ­çƒ­ç‚¹æ•°æ®
@Component
public class ScheduledCacheWarmup {
    
    @Autowired
    private CacheWarmupService cacheWarmupService;
    
    // æ¯å°æ—¶æ‰§è¡Œä¸€æ¬¡çƒ­ç‚¹æ•°æ®é¢„çƒ­
    @Scheduled(fixedRate = 3600000) // 1å°æ—¶ = 3600000æ¯«ç§’
    public void hourlyWarmup() {
        log.info("å¼€å§‹æ‰§è¡Œå®šæ—¶ç¼“å­˜é¢„çƒ­");
        
        try {
            // é¢„çƒ­æœ€è¿‘1å°æ—¶çš„çƒ­ç‚¹æ•°æ®
            cacheWarmupService.warmupRecentHotData(Duration.ofHours(1));
            
            log.info("å®šæ—¶ç¼“å­˜é¢„çƒ­å®Œæˆ");
        } catch (Exception e) {
            log.error("å®šæ—¶ç¼“å­˜é¢„çƒ­å¤±è´¥", e);
        }
    }
    
    // æ¯å¤©å‡Œæ™¨æ‰§è¡Œå…¨é‡é¢„çƒ­
    @Scheduled(cron = "0 0 2 * * ?") // æ¯å¤©å‡Œæ™¨2ç‚¹æ‰§è¡Œ
    public void dailyFullWarmup() {
        log.info("å¼€å§‹æ‰§è¡Œæ¯æ—¥å…¨é‡ç¼“å­˜é¢„çƒ­");
        
        try {
            // æ¸…ç†è¿‡æœŸç¼“å­˜
            cacheWarmupService.cleanExpiredCache();
            
            // å…¨é‡é¢„çƒ­
            cacheWarmupService.fullWarmup();
            
            log.info("æ¯æ—¥å…¨é‡ç¼“å­˜é¢„çƒ­å®Œæˆ");
        } catch (Exception e) {
            log.error("æ¯æ—¥å…¨é‡ç¼“å­˜é¢„çƒ­å¤±è´¥", e);
        }
    }
}
```

# ä¸‰ã€å¤šå±‚ç¼“å­˜æ¶æ„

## ï¼ˆä¸€ï¼‰åˆ†å±‚ç¼“å­˜è®¾è®¡

```javascript
// å¤šå±‚ç¼“å­˜æ¶æ„å®ç°ï¼šL1æœ¬åœ°ç¼“å­˜ + L2åˆ†å¸ƒå¼ç¼“å­˜ + L3æ•°æ®åº“
class MultiLevelCache {
    constructor() {
        // L1ç¼“å­˜ï¼šæœ¬åœ°å†…å­˜ç¼“å­˜ï¼ˆæœ€å¿«ï¼Œå®¹é‡æœ€å°ï¼‰
        this.l1Cache = new Map();
        this.l1MaxSize = 1000;
        this.l1TTL = 60000; // 1åˆ†é’Ÿ
        
        // L2ç¼“å­˜ï¼šRedisåˆ†å¸ƒå¼ç¼“å­˜ï¼ˆè¾ƒå¿«ï¼Œå®¹é‡ä¸­ç­‰ï¼‰
        this.l2Cache = new RedisClient();
        this.l2TTL = 3600; // 1å°æ—¶
        
        // L3ç¼“å­˜ï¼šæ•°æ®åº“ï¼ˆæœ€æ…¢ï¼Œå®¹é‡æœ€å¤§ï¼‰
        this.database = new DatabaseClient();
        
        // ç¼“å­˜ç»Ÿè®¡
        this.stats = {
            l1Hits: 0,
            l2Hits: 0,
            l3Hits: 0,
            misses: 0
        };
    }
    
    // æ™ºèƒ½ç¼“å­˜è·å–ï¼šæŒ‰å±‚çº§ä¾æ¬¡æŸ¥æ‰¾
    async get(key) {
        // L1ç¼“å­˜æ£€æŸ¥
        const l1Result = this.getFromL1(key);
        if (l1Result !== null) {
            this.stats.l1Hits++;
            return l1Result;
        }
        
        // L2ç¼“å­˜æ£€æŸ¥
        const l2Result = await this.getFromL2(key);
        if (l2Result !== null) {
            this.stats.l2Hits++;
            // çƒ­ç‚¹æ•°æ®æå‡åˆ°L1ç¼“å­˜
            this.setToL1(key, l2Result);
            return l2Result;
        }
        
        // L3æ•°æ®åº“æŸ¥è¯¢
        const l3Result = await this.getFromL3(key);
        if (l3Result !== null) {
            this.stats.l3Hits++;
            // æ•°æ®åŒæ—¶ç¼“å­˜åˆ°L1å’ŒL2
            this.setToL1(key, l3Result);
            await this.setToL2(key, l3Result);
            return l3Result;
        }
        
        this.stats.misses++;
        return null;
    }
    
    // L1æœ¬åœ°ç¼“å­˜æ“ä½œ
    getFromL1(key) {
        const item = this.l1Cache.get(key);
        if (item && item.expireAt > Date.now()) {
            return item.value;
        } else if (item) {
            this.l1Cache.delete(key); // æ¸…ç†è¿‡æœŸæ•°æ®
        }
        return null;
    }
    
    setToL1(key, value) {
        // æ£€æŸ¥å®¹é‡é™åˆ¶
        if (this.l1Cache.size >= this.l1MaxSize) {
            this.evictL1Cache();
        }
        
        this.l1Cache.set(key, {
            value: value,
            expireAt: Date.now() + this.l1TTL,
            accessTime: Date.now()
        });
    }
    
    // L1ç¼“å­˜æ·˜æ±°ï¼šLRUç­–ç•¥
    evictL1Cache() {
        let oldestKey = null;
        let oldestTime = Date.now();
        
        for (const [key, item] of this.l1Cache) {
            if (item.accessTime < oldestTime) {
                oldestTime = item.accessTime;
                oldestKey = key;
            }
        }
        
        if (oldestKey) {
            this.l1Cache.delete(oldestKey);
        }
    }
    
    // L2åˆ†å¸ƒå¼ç¼“å­˜æ“ä½œ
    async getFromL2(key) {
        try {
            const value = await this.l2Cache.get(key);
            return value ? JSON.parse(value) : null;
        } catch (error) {
            console.error('L2ç¼“å­˜è·å–å¤±è´¥:', error);
            return null;
        }
    }
    
    async setToL2(key, value) {
        try {
            await this.l2Cache.setex(key, this.l2TTL, JSON.stringify(value));
        } catch (error) {
            console.error('L2ç¼“å­˜è®¾ç½®å¤±è´¥:', error);
        }
    }
    
    // L3æ•°æ®åº“æ“ä½œ
    async getFromL3(key) {
        try {
            return await this.database.query(key);
        } catch (error) {
            console.error('æ•°æ®åº“æŸ¥è¯¢å¤±è´¥:', error);
            return null;
        }
    }
    
    // è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
    getStats() {
        const total = this.stats.l1Hits + this.stats.l2Hits + this.stats.l3Hits + this.stats.misses;
        
        return {
            l1HitRate: total > 0 ? (this.stats.l1Hits / total * 100).toFixed(2) + '%' : '0%',
            l2HitRate: total > 0 ? (this.stats.l2Hits / total * 100).toFixed(2) + '%' : '0%',
            l3HitRate: total > 0 ? (this.stats.l3Hits / total * 100).toFixed(2) + '%' : '0%',
            totalHitRate: total > 0 ? ((total - this.stats.misses) / total * 100).toFixed(2) + '%' : '0%',
            ...this.stats
        };
    }
}
```

## ï¼ˆäºŒï¼‰ç¼“å­˜ä¸€è‡´æ€§ä¿è¯

### 1. å†™å…¥æ—¶æ›´æ–°ç­–ç•¥

```java
// å†™å…¥æ—¶åŒæ­¥æ›´æ–°å¤šå±‚ç¼“å­˜
@Service
public class ConsistentCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    @Autowired
    private UserRepository userRepository;

    private final Map<String, Object> localCache = new ConcurrentHashMap<>();

    // æ›´æ–°ç”¨æˆ·ä¿¡æ¯ï¼šä¿è¯å¤šå±‚ç¼“å­˜ä¸€è‡´æ€§
    @Transactional
    public void updateUser(User user) {
        // 1. æ›´æ–°æ•°æ®åº“
        userRepository.save(user);

        // 2. æ›´æ–°L2ç¼“å­˜ï¼ˆRedisï¼‰
        String redisKey = "user:" + user.getId();
        redisTemplate.opsForValue().set(redisKey, user, Duration.ofHours(2));

        // 3. æ›´æ–°L1ç¼“å­˜ï¼ˆæœ¬åœ°ï¼‰
        String localKey = "user:" + user.getId();
        localCache.put(localKey, user);

        // 4. å‘å¸ƒç¼“å­˜æ›´æ–°äº‹ä»¶ï¼Œé€šçŸ¥å…¶ä»–èŠ‚ç‚¹
        publishCacheUpdateEvent(user.getId(), user);

        log.info("ç”¨æˆ·ä¿¡æ¯æ›´æ–°å®Œæˆï¼Œå·²åŒæ­¥æ‰€æœ‰ç¼“å­˜å±‚: userId={}", user.getId());
    }

    // åˆ é™¤ç”¨æˆ·ï¼šæ¸…ç†æ‰€æœ‰ç¼“å­˜å±‚
    @Transactional
    public void deleteUser(Long userId) {
        // 1. åˆ é™¤æ•°æ®åº“è®°å½•
        userRepository.deleteById(userId);

        // 2. åˆ é™¤L2ç¼“å­˜
        String redisKey = "user:" + userId;
        redisTemplate.delete(redisKey);

        // 3. åˆ é™¤L1ç¼“å­˜
        String localKey = "user:" + userId;
        localCache.remove(localKey);

        // 4. å‘å¸ƒç¼“å­˜åˆ é™¤äº‹ä»¶
        publishCacheDeleteEvent(userId);

        log.info("ç”¨æˆ·åˆ é™¤å®Œæˆï¼Œå·²æ¸…ç†æ‰€æœ‰ç¼“å­˜: userId={}", userId);
    }

    // å‘å¸ƒç¼“å­˜æ›´æ–°äº‹ä»¶
    private void publishCacheUpdateEvent(Long userId, User user) {
        CacheUpdateEvent event = new CacheUpdateEvent(userId, user, "UPDATE");
        applicationEventPublisher.publishEvent(event);
    }

    // å‘å¸ƒç¼“å­˜åˆ é™¤äº‹ä»¶
    private void publishCacheDeleteEvent(Long userId) {
        CacheUpdateEvent event = new CacheUpdateEvent(userId, null, "DELETE");
        applicationEventPublisher.publishEvent(event);
    }
}
```

### 2. ç¼“å­˜å¤±æ•ˆç­–ç•¥

```java
// åŸºäºTTLå’Œç‰ˆæœ¬å·çš„ç¼“å­˜å¤±æ•ˆæœºåˆ¶
@Component
public class CacheInvalidationService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // è®¾ç½®å¸¦ç‰ˆæœ¬å·çš„ç¼“å­˜
    public void setVersionedCache(String key, Object value, Duration ttl) {
        VersionedCacheItem item = new VersionedCacheItem(
            value,
            System.currentTimeMillis(),
            generateVersion()
        );

        redisTemplate.opsForValue().set(key, item, ttl);
    }

    // è·å–ç‰ˆæœ¬åŒ–ç¼“å­˜
    public Object getVersionedCache(String key) {
        VersionedCacheItem item = (VersionedCacheItem) redisTemplate.opsForValue().get(key);

        if (item == null) {
            return null;
        }

        // æ£€æŸ¥ç‰ˆæœ¬æ˜¯å¦æœ‰æ•ˆ
        if (isVersionValid(key, item.getVersion())) {
            return item.getValue();
        } else {
            // ç‰ˆæœ¬å¤±æ•ˆï¼Œåˆ é™¤ç¼“å­˜
            redisTemplate.delete(key);
            return null;
        }
    }

    // ä¸»åŠ¨å¤±æ•ˆç›¸å…³ç¼“å­˜
    public void invalidateRelatedCaches(String pattern) {
        Set<String> keys = redisTemplate.keys(pattern);
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
            log.info("æ‰¹é‡å¤±æ•ˆç¼“å­˜å®Œæˆï¼Œæ¨¡å¼: {}, æ•°é‡: {}", pattern, keys.size());
        }
    }

    // ç”Ÿæˆç‰ˆæœ¬å·
    private String generateVersion() {
        return String.valueOf(System.currentTimeMillis());
    }

    // æ£€æŸ¥ç‰ˆæœ¬æœ‰æ•ˆæ€§
    private boolean isVersionValid(String key, String version) {
        // å¯ä»¥æ ¹æ®ä¸šåŠ¡é€»è¾‘å®ç°ç‰ˆæœ¬æ£€æŸ¥
        // ä¾‹å¦‚ï¼šæ£€æŸ¥æ•°æ®æœ€åæ›´æ–°æ—¶é—´
        return true;
    }
}

// ç‰ˆæœ¬åŒ–ç¼“å­˜é¡¹
@Data
@AllArgsConstructor
public class VersionedCacheItem {
    private Object value;
    private long timestamp;
    private String version;
}
```

# å››ã€ç¼“å­˜é”®è®¾è®¡ä¼˜åŒ–

## ï¼ˆä¸€ï¼‰ç¼“å­˜é”®å‘½åè§„èŒƒ

```java
// ç¼“å­˜é”®è®¾è®¡æœ€ä½³å®è·µ
public class CacheKeyDesign {

    // ç¼“å­˜é”®å‰ç¼€å¸¸é‡
    public static final String USER_PREFIX = "user";
    public static final String PRODUCT_PREFIX = "product";
    public static final String ORDER_PREFIX = "order";
    public static final String SESSION_PREFIX = "session";

    // åˆ†éš”ç¬¦
    public static final String SEPARATOR = ":";

    // æ„å»ºç”¨æˆ·ç¼“å­˜é”®
    public static String buildUserKey(Long userId) {
        return USER_PREFIX + SEPARATOR + userId;
    }

    // æ„å»ºç”¨æˆ·è¯¦æƒ…ç¼“å­˜é”®
    public static String buildUserDetailKey(Long userId) {
        return USER_PREFIX + SEPARATOR + "detail" + SEPARATOR + userId;
    }

    // æ„å»ºç”¨æˆ·æƒé™ç¼“å­˜é”®
    public static String buildUserPermissionKey(Long userId) {
        return USER_PREFIX + SEPARATOR + "permission" + SEPARATOR + userId;
    }

    // æ„å»ºå•†å“åˆ—è¡¨ç¼“å­˜é”®ï¼ˆæ”¯æŒåˆ†é¡µï¼‰
    public static String buildProductListKey(int page, int size, String category) {
        return PRODUCT_PREFIX + SEPARATOR + "list" + SEPARATOR +
               "page" + SEPARATOR + page + SEPARATOR +
               "size" + SEPARATOR + size + SEPARATOR +
               "category" + SEPARATOR + category;
    }

    // æ„å»ºæœç´¢ç»“æœç¼“å­˜é”®
    public static String buildSearchKey(String keyword, int page, int size) {
        // å¯¹å…³é”®è¯è¿›è¡ŒMD5ç¼–ç ï¼Œé¿å…ç‰¹æ®Šå­—ç¬¦é—®é¢˜
        String encodedKeyword = DigestUtils.md5Hex(keyword);
        return "search" + SEPARATOR + encodedKeyword + SEPARATOR +
               "page" + SEPARATOR + page + SEPARATOR +
               "size" + SEPARATOR + size;
    }

    // æ„å»ºä¼šè¯ç¼“å­˜é”®
    public static String buildSessionKey(String sessionId) {
        return SESSION_PREFIX + SEPARATOR + sessionId;
    }

    // æ„å»ºè®¡æ•°å™¨ç¼“å­˜é”®
    public static String buildCounterKey(String type, String identifier) {
        return "counter" + SEPARATOR + type + SEPARATOR + identifier;
    }
}
```

## ï¼ˆäºŒï¼‰ç¼“å­˜é”®åˆ†ç‰‡ç­–ç•¥

```java
// ç¼“å­˜é”®åˆ†ç‰‡ï¼šé¿å…çƒ­ç‚¹é”®é—®é¢˜
@Component
public class ShardedCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private static final int SHARD_COUNT = 16; // åˆ†ç‰‡æ•°é‡

    // åˆ†ç‰‡ç¼“å­˜è®¾ç½®
    public void setShardedCache(String baseKey, Object value, Duration ttl) {
        String shardedKey = getShardedKey(baseKey);
        redisTemplate.opsForValue().set(shardedKey, value, ttl);
    }

    // åˆ†ç‰‡ç¼“å­˜è·å–
    public Object getShardedCache(String baseKey) {
        String shardedKey = getShardedKey(baseKey);
        return redisTemplate.opsForValue().get(shardedKey);
    }

    // è®¡ç®—åˆ†ç‰‡é”®
    private String getShardedKey(String baseKey) {
        int hash = baseKey.hashCode();
        int shardIndex = Math.abs(hash) % SHARD_COUNT;
        return baseKey + ":shard:" + shardIndex;
    }

    // çƒ­ç‚¹æ•°æ®åˆ†æ•£å­˜å‚¨
    public void setHotDataWithSharding(String key, Object value, Duration ttl) {
        // å°†çƒ­ç‚¹æ•°æ®å­˜å‚¨åˆ°å¤šä¸ªåˆ†ç‰‡ä¸­
        for (int i = 0; i < 3; i++) { // å­˜å‚¨3ä¸ªå‰¯æœ¬
            String shardKey = key + ":hot:shard:" + i;
            redisTemplate.opsForValue().set(shardKey, value, ttl);
        }
    }

    // ä»çƒ­ç‚¹æ•°æ®åˆ†ç‰‡ä¸­éšæœºè·å–
    public Object getHotDataFromSharding(String key) {
        // éšæœºé€‰æ‹©ä¸€ä¸ªåˆ†ç‰‡è¯»å–ï¼Œåˆ†æ•£è¯»å‹åŠ›
        int randomShard = ThreadLocalRandom.current().nextInt(3);
        String shardKey = key + ":hot:shard:" + randomShard;

        Object value = redisTemplate.opsForValue().get(shardKey);
        if (value == null) {
            // å¦‚æœéšæœºåˆ†ç‰‡æ²¡æœ‰æ•°æ®ï¼Œå°è¯•å…¶ä»–åˆ†ç‰‡
            for (int i = 0; i < 3; i++) {
                if (i != randomShard) {
                    shardKey = key + ":hot:shard:" + i;
                    value = redisTemplate.opsForValue().get(shardKey);
                    if (value != null) {
                        break;
                    }
                }
            }
        }

        return value;
    }
}
```

# äº”ã€ç¼“å­˜ç›‘æ§ä¸è°ƒä¼˜

## ï¼ˆä¸€ï¼‰ç¼“å­˜æ€§èƒ½ç›‘æ§

```java
// ç¼“å­˜æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
@Component
public class CacheMonitorService {

    private final MeterRegistry meterRegistry;
    private final Timer cacheTimer;
    private final Counter cacheHitCounter;
    private final Counter cacheMissCounter;
    private final Gauge cacheSize;

    public CacheMonitorService(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;

        // ç¼“å­˜æ“ä½œè€—æ—¶ç›‘æ§
        this.cacheTimer = Timer.builder("cache.operation.duration")
                .description("ç¼“å­˜æ“ä½œè€—æ—¶")
                .register(meterRegistry);

        // ç¼“å­˜å‘½ä¸­è®¡æ•°å™¨
        this.cacheHitCounter = Counter.builder("cache.hit")
                .description("ç¼“å­˜å‘½ä¸­æ¬¡æ•°")
                .register(meterRegistry);

        // ç¼“å­˜æœªå‘½ä¸­è®¡æ•°å™¨
        this.cacheMissCounter = Counter.builder("cache.miss")
                .description("ç¼“å­˜æœªå‘½ä¸­æ¬¡æ•°")
                .register(meterRegistry);

        // ç¼“å­˜å¤§å°ç›‘æ§
        this.cacheSize = Gauge.builder("cache.size")
                .description("ç¼“å­˜å¤§å°")
                .register(meterRegistry, this, CacheMonitorService::getCurrentCacheSize);
    }

    // ç›‘æ§ç¼“å­˜æ“ä½œ
    public <T> T monitorCacheOperation(String operation, Supplier<T> cacheOperation) {
        return cacheTimer.recordCallable(() -> {
            long startTime = System.currentTimeMillis();

            try {
                T result = cacheOperation.get();

                // è®°å½•å‘½ä¸­æˆ–æœªå‘½ä¸­
                if (result != null) {
                    cacheHitCounter.increment();
                } else {
                    cacheMissCounter.increment();
                }

                return result;
            } finally {
                long duration = System.currentTimeMillis() - startTime;
                log.debug("ç¼“å­˜æ“ä½œå®Œæˆ: operation={}, duration={}ms", operation, duration);
            }
        });
    }

    // è·å–å½“å‰ç¼“å­˜å¤§å°
    private double getCurrentCacheSize() {
        // è¿™é‡Œå¯ä»¥å®ç°è·å–å®é™…ç¼“å­˜å¤§å°çš„é€»è¾‘
        return 0.0;
    }

    // è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
    public CacheStats getCacheStats() {
        double hitCount = cacheHitCounter.count();
        double missCount = cacheMissCounter.count();
        double totalCount = hitCount + missCount;
        double hitRate = totalCount > 0 ? (hitCount / totalCount) * 100 : 0;

        return CacheStats.builder()
                .hitCount((long) hitCount)
                .missCount((long) missCount)
                .hitRate(hitRate)
                .averageLoadTime(cacheTimer.mean(TimeUnit.MILLISECONDS))
                .build();
    }
}

// ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
@Data
@Builder
public class CacheStats {
    private long hitCount;      // å‘½ä¸­æ¬¡æ•°
    private long missCount;     // æœªå‘½ä¸­æ¬¡æ•°
    private double hitRate;     // å‘½ä¸­ç‡
    private double averageLoadTime; // å¹³å‡åŠ è½½æ—¶é—´
}
```

## ï¼ˆäºŒï¼‰ç¼“å­˜è°ƒä¼˜å®è·µ

### 1. ç¼“å­˜å®¹é‡è§„åˆ’

```python
# ç¼“å­˜å®¹é‡è§„åˆ’å·¥å…·
class CacheCapacityPlanner:
    def __init__(self):
        self.memory_overhead = 0.2  # 20%çš„å†…å­˜å¼€é”€
        self.safety_margin = 0.8    # 80%çš„å®‰å…¨è¾¹é™…

    def calculate_optimal_size(self, available_memory_mb, avg_object_size_kb, hit_rate_target):
        """
        è®¡ç®—æœ€ä¼˜ç¼“å­˜å¤§å°

        Args:
            available_memory_mb: å¯ç”¨å†…å­˜ï¼ˆMBï¼‰
            avg_object_size_kb: å¹³å‡å¯¹è±¡å¤§å°ï¼ˆKBï¼‰
            hit_rate_target: ç›®æ ‡å‘½ä¸­ç‡
        """
        # è€ƒè™‘å†…å­˜å¼€é”€çš„å®é™…å¯ç”¨å†…å­˜
        usable_memory_mb = available_memory_mb * (1 - self.memory_overhead) * self.safety_margin

        # è½¬æ¢ä¸ºKB
        usable_memory_kb = usable_memory_mb * 1024

        # è®¡ç®—å¯å­˜å‚¨çš„å¯¹è±¡æ•°é‡
        max_objects = int(usable_memory_kb / avg_object_size_kb)

        # æ ¹æ®ç›®æ ‡å‘½ä¸­ç‡è°ƒæ•´
        recommended_objects = int(max_objects * hit_rate_target)

        return {
            'max_objects': max_objects,
            'recommended_objects': recommended_objects,
            'estimated_memory_usage_mb': (recommended_objects * avg_object_size_kb) / 1024,
            'estimated_hit_rate': hit_rate_target
        }

    def analyze_workload(self, access_pattern):
        """
        åˆ†æè®¿é—®æ¨¡å¼ï¼Œæä¾›ç¼“å­˜ç­–ç•¥å»ºè®®

        Args:
            access_pattern: è®¿é—®æ¨¡å¼æ•°æ® {'key': access_count}
        """
        total_accesses = sum(access_pattern.values())
        sorted_keys = sorted(access_pattern.items(), key=lambda x: x[1], reverse=True)

        # è®¡ç®—80/20è§„åˆ™çš„å®é™…æ¯”ä¾‹
        cumulative_accesses = 0
        hot_keys_count = 0

        for key, count in sorted_keys:
            cumulative_accesses += count
            hot_keys_count += 1

            if cumulative_accesses >= total_accesses * 0.8:
                break

        hot_keys_ratio = hot_keys_count / len(access_pattern)

        return {
            'total_keys': len(access_pattern),
            'hot_keys_count': hot_keys_count,
            'hot_keys_ratio': hot_keys_ratio,
            'recommendation': self._get_strategy_recommendation(hot_keys_ratio)
        }

    def _get_strategy_recommendation(self, hot_keys_ratio):
        """æ ¹æ®çƒ­ç‚¹æ•°æ®æ¯”ä¾‹æ¨èç¼“å­˜ç­–ç•¥"""
        if hot_keys_ratio < 0.1:
            return "æ•°æ®è®¿é—®é«˜åº¦é›†ä¸­ï¼Œå»ºè®®ä½¿ç”¨å°å®¹é‡LRUç¼“å­˜"
        elif hot_keys_ratio < 0.3:
            return "æ•°æ®è®¿é—®è¾ƒä¸ºé›†ä¸­ï¼Œå»ºè®®ä½¿ç”¨ä¸­ç­‰å®¹é‡LRUç¼“å­˜"
        else:
            return "æ•°æ®è®¿é—®è¾ƒä¸ºåˆ†æ•£ï¼Œå»ºè®®ä½¿ç”¨å¤§å®¹é‡LFUç¼“å­˜æˆ–åˆ†å±‚ç¼“å­˜"
```

### 2. ç¼“å­˜é¢„æµ‹ä¸è‡ªé€‚åº”è°ƒæ•´

```java
// è‡ªé€‚åº”ç¼“å­˜è°ƒæ•´æœåŠ¡
@Service
public class AdaptiveCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private final Map<String, CacheMetrics> metricsMap = new ConcurrentHashMap<>();
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(2);

    @PostConstruct
    public void init() {
        // æ¯5åˆ†é’Ÿåˆ†æä¸€æ¬¡ç¼“å­˜æ€§èƒ½
        scheduler.scheduleAtFixedRate(this::analyzeCachePerformance, 5, 5, TimeUnit.MINUTES);

        // æ¯å°æ—¶è°ƒæ•´ä¸€æ¬¡ç¼“å­˜ç­–ç•¥
        scheduler.scheduleAtFixedRate(this::adjustCacheStrategy, 60, 60, TimeUnit.MINUTES);
    }

    // è®°å½•ç¼“å­˜è®¿é—®
    public void recordCacheAccess(String key, boolean hit) {
        metricsMap.computeIfAbsent(key, k -> new CacheMetrics()).recordAccess(hit);
    }

    // åˆ†æç¼“å­˜æ€§èƒ½
    private void analyzeCachePerformance() {
        Map<String, Double> hitRates = new HashMap<>();

        metricsMap.forEach((key, metrics) -> {
            double hitRate = metrics.getHitRate();
            hitRates.put(key, hitRate);

            // é‡ç½®è®¡æ•°å™¨
            metrics.reset();
        });

        // è¯†åˆ«ä½å‘½ä¸­ç‡çš„ç¼“å­˜é”®
        List<String> lowHitRateKeys = hitRates.entrySet().stream()
                .filter(entry -> entry.getValue() < 0.5) // å‘½ä¸­ç‡ä½äº50%
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        if (!lowHitRateKeys.isEmpty()) {
            log.warn("å‘ç°ä½å‘½ä¸­ç‡ç¼“å­˜é”®: {}", lowHitRateKeys);
            // å¯ä»¥è€ƒè™‘è°ƒæ•´è¿™äº›é”®çš„TTLæˆ–ç¼“å­˜ç­–ç•¥
        }
    }

    // è°ƒæ•´ç¼“å­˜ç­–ç•¥
    private void adjustCacheStrategy() {
        // è·å–Rediså†…å­˜ä½¿ç”¨æƒ…å†µ
        RedisInfo redisInfo = getRedisInfo();

        if (redisInfo.getMemoryUsageRatio() > 0.8) {
            // å†…å­˜ä½¿ç”¨ç‡è¿‡é«˜ï¼Œç¼©çŸ­TTL
            adjustTTLForHighMemoryUsage();
        } else if (redisInfo.getMemoryUsageRatio() < 0.5) {
            // å†…å­˜ä½¿ç”¨ç‡è¾ƒä½ï¼Œå¯ä»¥å»¶é•¿TTL
            adjustTTLForLowMemoryUsage();
        }
    }

    // é«˜å†…å­˜ä½¿ç”¨æ—¶è°ƒæ•´TTL
    private void adjustTTLForHighMemoryUsage() {
        // è·å–æ‰€æœ‰é”®å¹¶æŒ‰è®¿é—®é¢‘ç‡æ’åº
        Set<String> keys = redisTemplate.keys("*");
        if (keys != null) {
            for (String key : keys) {
                Long ttl = redisTemplate.getExpire(key);
                if (ttl != null && ttl > 3600) { // TTLå¤§äº1å°æ—¶
                    // ç¼©çŸ­TTLåˆ°åŸæ¥çš„80%
                    redisTemplate.expire(key, Duration.ofSeconds((long) (ttl * 0.8)));
                }
            }
        }

        log.info("ç”±äºå†…å­˜ä½¿ç”¨ç‡è¿‡é«˜ï¼Œå·²è°ƒæ•´ç¼“å­˜TTL");
    }

    // ä½å†…å­˜ä½¿ç”¨æ—¶è°ƒæ•´TTL
    private void adjustTTLForLowMemoryUsage() {
        // å¯¹äºé«˜å‘½ä¸­ç‡çš„é”®ï¼Œå¯ä»¥é€‚å½“å»¶é•¿TTL
        metricsMap.entrySet().stream()
                .filter(entry -> entry.getValue().getHitRate() > 0.8)
                .forEach(entry -> {
                    String key = entry.getKey();
                    Long ttl = redisTemplate.getExpire(key);
                    if (ttl != null && ttl > 0 && ttl < 7200) { // TTLå°äº2å°æ—¶
                        // å»¶é•¿TTLåˆ°åŸæ¥çš„120%
                        redisTemplate.expire(key, Duration.ofSeconds((long) (ttl * 1.2)));
                    }
                });

        log.info("ç”±äºå†…å­˜ä½¿ç”¨ç‡è¾ƒä½ï¼Œå·²å»¶é•¿é«˜å‘½ä¸­ç‡ç¼“å­˜çš„TTL");
    }

    // è·å–Redisä¿¡æ¯
    private RedisInfo getRedisInfo() {
        // è¿™é‡Œåº”è¯¥å®ç°è·å–Rediså†…å­˜ä½¿ç”¨æƒ…å†µçš„é€»è¾‘
        return new RedisInfo(0.6); // ç¤ºä¾‹ï¼š60%å†…å­˜ä½¿ç”¨ç‡
    }
}

// ç¼“å­˜æŒ‡æ ‡ç±»
@Data
public class CacheMetrics {
    private long hits = 0;
    private long misses = 0;

    public void recordAccess(boolean hit) {
        if (hit) {
            hits++;
        } else {
            misses++;
        }
    }

    public double getHitRate() {
        long total = hits + misses;
        return total > 0 ? (double) hits / total : 0.0;
    }

    public void reset() {
        hits = 0;
        misses = 0;
    }
}

// Redisä¿¡æ¯ç±»
@Data
@AllArgsConstructor
public class RedisInfo {
    private double memoryUsageRatio; // å†…å­˜ä½¿ç”¨ç‡
}
```

# å…­ã€å®é™…åº”ç”¨åœºæ™¯ä¸æœ€ä½³å®è·µ

## ï¼ˆä¸€ï¼‰ç”µå•†ç³»ç»Ÿç¼“å­˜ä¼˜åŒ–

```java
// ç”µå•†ç³»ç»Ÿç¼“å­˜ç­–ç•¥å®ç°
@Service
public class EcommerceCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    // å•†å“ä¿¡æ¯ç¼“å­˜ï¼šçƒ­ç‚¹å•†å“é•¿æœŸç¼“å­˜ï¼Œæ™®é€šå•†å“çŸ­æœŸç¼“å­˜
    public Product getProduct(Long productId) {
        String cacheKey = "product:" + productId;

        // å…ˆä»ç¼“å­˜è·å–
        Product product = (Product) redisTemplate.opsForValue().get(cacheKey);
        if (product != null) {
            return product;
        }

        // ç¼“å­˜æœªå‘½ä¸­ï¼Œä»æ•°æ®åº“è·å–
        product = productRepository.findById(productId).orElse(null);
        if (product != null) {
            // æ ¹æ®å•†å“çƒ­åº¦è®¾ç½®ä¸åŒçš„TTL
            Duration ttl = calculateProductCacheTTL(product);
            redisTemplate.opsForValue().set(cacheKey, product, ttl);
        }

        return product;
    }

    // æ ¹æ®å•†å“çƒ­åº¦è®¡ç®—ç¼“å­˜TTL
    private Duration calculateProductCacheTTL(Product product) {
        // è·å–å•†å“çš„è®¿é—®çƒ­åº¦
        int hotScore = getProductHotScore(product.getId());

        if (hotScore > 1000) {
            return Duration.ofHours(24);    // çƒ­é—¨å•†å“ç¼“å­˜24å°æ—¶
        } else if (hotScore > 100) {
            return Duration.ofHours(6);     // ä¸­ç­‰çƒ­åº¦å•†å“ç¼“å­˜6å°æ—¶
        } else {
            return Duration.ofHours(1);     // æ™®é€šå•†å“ç¼“å­˜1å°æ—¶
        }
    }

    // å•†å“åˆ—è¡¨ç¼“å­˜ï¼šåˆ†é¡µç¼“å­˜ç­–ç•¥
    public List<Product> getProductList(int page, int size, String category) {
        String cacheKey = CacheKeyDesign.buildProductListKey(page, size, category);

        // æ£€æŸ¥ç¼“å­˜
        List<Product> products = (List<Product>) redisTemplate.opsForValue().get(cacheKey);
        if (products != null) {
            return products;
        }

        // ä»æ•°æ®åº“æŸ¥è¯¢
        products = productRepository.findByCategory(category, PageRequest.of(page, size));

        // ç¼“å­˜ç»“æœï¼Œé¦–é¡µç¼“å­˜æ—¶é—´æ›´é•¿
        Duration ttl = page == 0 ? Duration.ofMinutes(30) : Duration.ofMinutes(10);
        redisTemplate.opsForValue().set(cacheKey, products, ttl);

        return products;
    }

    // è´­ç‰©è½¦ç¼“å­˜ï¼šç”¨æˆ·ä¼šè¯çº§ç¼“å­˜
    public Cart getUserCart(Long userId) {
        String cacheKey = "cart:" + userId;

        Cart cart = (Cart) redisTemplate.opsForValue().get(cacheKey);
        if (cart == null) {
            cart = cartRepository.findByUserId(userId);
            if (cart != null) {
                // è´­ç‰©è½¦ç¼“å­˜30åˆ†é’Ÿï¼Œä¸ç”¨æˆ·ä¼šè¯æ—¶é—´åŒ¹é…
                redisTemplate.opsForValue().set(cacheKey, cart, Duration.ofMinutes(30));
            }
        }

        return cart;
    }

    // åº“å­˜ç¼“å­˜ï¼šé«˜é¢‘æ›´æ–°æ•°æ®çš„ç¼“å­˜ç­–ç•¥
    public Integer getProductStock(Long productId) {
        String cacheKey = "stock:" + productId;

        // ä½¿ç”¨RedisåŸå­æ“ä½œè·å–åº“å­˜
        Integer stock = (Integer) redisTemplate.opsForValue().get(cacheKey);
        if (stock == null) {
            // ä»æ•°æ®åº“åŒæ­¥åº“å­˜åˆ°ç¼“å­˜
            stock = productRepository.getStock(productId);
            redisTemplate.opsForValue().set(cacheKey, stock, Duration.ofMinutes(5));
        }

        return stock;
    }

    // å‡åº“å­˜æ“ä½œï¼šä¿è¯æ•°æ®ä¸€è‡´æ€§
    @Transactional
    public boolean decreaseStock(Long productId, int quantity) {
        String cacheKey = "stock:" + productId;

        // ä½¿ç”¨Luaè„šæœ¬ä¿è¯åŸå­æ€§
        String luaScript =
            "local current = redis.call('get', KEYS[1]) " +
            "if current == false then " +
            "  return -1 " +
            "end " +
            "current = tonumber(current) " +
            "if current >= tonumber(ARGV[1]) then " +
            "  redis.call('decrby', KEYS[1], ARGV[1]) " +
            "  return current - tonumber(ARGV[1]) " +
            "else " +
            "  return -2 " +
            "end";

        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(luaScript, Long.class),
            Collections.singletonList(cacheKey),
            String.valueOf(quantity)
        );

        if (result >= 0) {
            // ç¼“å­˜æ“ä½œæˆåŠŸï¼ŒåŒæ­¥æ›´æ–°æ•°æ®åº“
            productRepository.decreaseStock(productId, quantity);
            return true;
        } else {
            // åº“å­˜ä¸è¶³æˆ–ç¼“å­˜å¤±æ•ˆ
            return false;
        }
    }
}
```

## ï¼ˆäºŒï¼‰ç¤¾äº¤åª’ä½“ç³»ç»Ÿç¼“å­˜ä¼˜åŒ–

```python
# ç¤¾äº¤åª’ä½“ç³»ç»Ÿçš„ç¼“å­˜ç­–ç•¥
class SocialMediaCacheService:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.local_cache = {}  # æœ¬åœ°ç¼“å­˜

    def get_user_timeline(self, user_id, page=1, size=20):
        """è·å–ç”¨æˆ·æ—¶é—´çº¿ï¼šæ¨æ‹‰ç»“åˆçš„ç¼“å­˜ç­–ç•¥"""
        cache_key = f"timeline:{user_id}:page:{page}"

        # æ£€æŸ¥æœ¬åœ°ç¼“å­˜ï¼ˆçƒ­ç‚¹ç”¨æˆ·ï¼‰
        if cache_key in self.local_cache:
            timeline_data = self.local_cache[cache_key]
            if not self._is_expired(timeline_data):
                return timeline_data['content']

        # æ£€æŸ¥Redisç¼“å­˜
        timeline = self.redis.get(cache_key)
        if timeline:
            timeline_data = json.loads(timeline)
            # çƒ­ç‚¹æ•°æ®æå‡åˆ°æœ¬åœ°ç¼“å­˜
            if self._is_hot_user(user_id):
                self.local_cache[cache_key] = {
                    'content': timeline_data,
                    'expire_at': time.time() + 300  # 5åˆ†é’Ÿæœ¬åœ°ç¼“å­˜
                }
            return timeline_data

        # ç¼“å­˜æœªå‘½ä¸­ï¼Œç”Ÿæˆæ—¶é—´çº¿
        timeline_data = self._generate_timeline(user_id, page, size)

        # ç¼“å­˜åˆ°Redis
        ttl = 1800 if page == 1 else 600  # é¦–é¡µç¼“å­˜30åˆ†é’Ÿï¼Œå…¶ä»–é¡µé¢10åˆ†é’Ÿ
        self.redis.setex(cache_key, ttl, json.dumps(timeline_data))

        return timeline_data

    def get_post_engagement(self, post_id):
        """è·å–å¸–å­äº’åŠ¨æ•°æ®ï¼šå®æ—¶æ›´æ–°çš„ç¼“å­˜ç­–ç•¥"""
        cache_key = f"engagement:{post_id}"

        # ä½¿ç”¨Redis Hashå­˜å‚¨å¤šä¸ªæŒ‡æ ‡
        engagement = self.redis.hgetall(cache_key)
        if engagement:
            return {
                'likes': int(engagement.get('likes', 0)),
                'comments': int(engagement.get('comments', 0)),
                'shares': int(engagement.get('shares', 0)),
                'views': int(engagement.get('views', 0))
            }

        # ä»æ•°æ®åº“è·å–å¹¶ç¼“å­˜
        engagement_data = self._get_engagement_from_db(post_id)

        # ä½¿ç”¨Pipelineæ‰¹é‡è®¾ç½®
        pipe = self.redis.pipeline()
        pipe.hset(cache_key, mapping=engagement_data)
        pipe.expire(cache_key, 300)  # 5åˆ†é’Ÿè¿‡æœŸ
        pipe.execute()

        return engagement_data

    def update_post_engagement(self, post_id, action, delta=1):
        """æ›´æ–°å¸–å­äº’åŠ¨ï¼šåŸå­æ“ä½œä¿è¯ä¸€è‡´æ€§"""
        cache_key = f"engagement:{post_id}"

        # ä½¿ç”¨RedisåŸå­æ“ä½œæ›´æ–°
        if action in ['likes', 'comments', 'shares', 'views']:
            self.redis.hincrby(cache_key, action, delta)
            self.redis.expire(cache_key, 300)  # é‡ç½®è¿‡æœŸæ—¶é—´

            # å¼‚æ­¥æ›´æ–°æ•°æ®åº“
            self._async_update_db(post_id, action, delta)

    def get_trending_topics(self, limit=10):
        """è·å–çƒ­é—¨è¯é¢˜ï¼šåŸºäºæ—¶é—´çª—å£çš„ç¼“å­˜"""
        cache_key = "trending:topics"

        # æ£€æŸ¥ç¼“å­˜
        topics = self.redis.get(cache_key)
        if topics:
            return json.loads(topics)

        # è®¡ç®—çƒ­é—¨è¯é¢˜
        trending_topics = self._calculate_trending_topics(limit)

        # ç¼“å­˜15åˆ†é’Ÿ
        self.redis.setex(cache_key, 900, json.dumps(trending_topics))

        return trending_topics

    def _is_hot_user(self, user_id):
        """åˆ¤æ–­æ˜¯å¦ä¸ºçƒ­ç‚¹ç”¨æˆ·"""
        follower_count = self.redis.get(f"followers:{user_id}")
        return follower_count and int(follower_count) > 10000

    def _is_expired(self, cache_data):
        """æ£€æŸ¥æœ¬åœ°ç¼“å­˜æ˜¯å¦è¿‡æœŸ"""
        return time.time() > cache_data.get('expire_at', 0)
```

# ä¸ƒã€æ€»ç»“ä¸å±•æœ›

## ï¼ˆä¸€ï¼‰ç¼“å­˜å‘½ä¸­ç‡ä¼˜åŒ–æ ¸å¿ƒè¦ç‚¹

{% note success %}
**å…³é”®ç­–ç•¥æ€»ç»“**

1. **é€‰æ‹©åˆé€‚çš„ç¼“å­˜ç®—æ³•**ï¼šæ ¹æ®æ•°æ®è®¿é—®æ¨¡å¼é€‰æ‹©LRUã€LFUæˆ–å…¶ä»–ç®—æ³•
2. **å®æ–½å¤šå±‚ç¼“å­˜æ¶æ„**ï¼šL1æœ¬åœ°ç¼“å­˜ + L2åˆ†å¸ƒå¼ç¼“å­˜ + L3æ•°æ®åº“çš„åˆ†å±‚è®¾è®¡
3. **ä¼˜åŒ–ç¼“å­˜é”®è®¾è®¡**ï¼šè§„èŒƒå‘½åã€åˆç†åˆ†ç‰‡ã€é¿å…çƒ­ç‚¹é”®é—®é¢˜
4. **å®ç°æ™ºèƒ½é¢„çƒ­ç­–ç•¥**ï¼šç³»ç»Ÿå¯åŠ¨é¢„çƒ­ + å®šæ—¶é¢„çƒ­ + æŒ‰éœ€é¢„çƒ­
5. **ä¿è¯ç¼“å­˜ä¸€è‡´æ€§**ï¼šå†™å…¥æ—¶æ›´æ–°ã€ç‰ˆæœ¬æ§åˆ¶ã€ä¸»åŠ¨å¤±æ•ˆæœºåˆ¶
6. **æŒç»­ç›‘æ§å’Œè°ƒä¼˜**ï¼šå®æ—¶ç›‘æ§å‘½ä¸­ç‡ã€è‡ªé€‚åº”è°ƒæ•´ç­–ç•¥
{% endnote %}

## ï¼ˆäºŒï¼‰æ€§èƒ½æå‡æ•ˆæœ

é€šè¿‡ç³»ç»Ÿæ€§çš„ç¼“å­˜ä¼˜åŒ–ï¼Œé€šå¸¸å¯ä»¥å®ç°ï¼š

- **å“åº”æ—¶é—´**ï¼šå‡å°‘50%-90%çš„æ•°æ®åº“æŸ¥è¯¢æ—¶é—´
- **ç³»ç»Ÿååé‡**ï¼šæå‡2-10å€çš„å¹¶å‘å¤„ç†èƒ½åŠ›
- **èµ„æºåˆ©ç”¨ç‡**ï¼šé™ä½60%-80%çš„æ•°æ®åº“è´Ÿè½½
- **ç”¨æˆ·ä½“éªŒ**ï¼šé¡µé¢åŠ è½½é€Ÿåº¦æå‡3-5å€

## ï¼ˆä¸‰ï¼‰æœªæ¥å‘å±•è¶‹åŠ¿

**æ™ºèƒ½åŒ–ç¼“å­˜**ï¼š
- åŸºäºæœºå™¨å­¦ä¹ çš„ç¼“å­˜é¢„æµ‹
- è‡ªé€‚åº”ç¼“å­˜ç­–ç•¥è°ƒæ•´
- æ™ºèƒ½çƒ­ç‚¹æ•°æ®è¯†åˆ«

**è¾¹ç¼˜ç¼“å­˜**ï¼š
- CDNä¸åº”ç”¨ç¼“å­˜çš„æ·±åº¦èåˆ
- è¾¹ç¼˜è®¡ç®—èŠ‚ç‚¹çš„ç¼“å­˜ä¼˜åŒ–
- åœ°ç†ä½ç½®æ„ŸçŸ¥çš„ç¼“å­˜åˆ†å¸ƒ

**æ–°æŠ€æœ¯åº”ç”¨**ï¼š
- å†…å­˜æ•°æ®åº“çš„æ™®åŠåº”ç”¨
- æŒä¹…åŒ–å†…å­˜æŠ€æœ¯çš„å‘å±•
- åˆ†å¸ƒå¼ç¼“å­˜çš„æ ‡å‡†åŒ–

## å‚è€ƒèµ„æ–™

1. **æŠ€æœ¯æ–‡æ¡£**
   - Rediså®˜æ–¹æ–‡æ¡£ï¼šhttps://redis.io/documentation
   - Caffeineç¼“å­˜åº“ï¼šhttps://github.com/ben-manes/caffeine
   - Spring CacheæŠ½è±¡ï¼šhttps://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache

2. **ç»å…¸ä¹¦ç±**
   - ã€ŠRedisè®¾è®¡ä¸å®ç°ã€‹- é»„å¥å®
   - ã€Šé«˜æ€§èƒ½MySQLã€‹- Baron Schwartz
   - ã€Šå¤§è§„æ¨¡åˆ†å¸ƒå¼å­˜å‚¨ç³»ç»Ÿã€‹- æ¨ä¼ è¾‰

3. **ç›¸å…³æ–‡ç« **
   - [ã€æ•°æ®åº“ã€‘Redisè¯¦è§£ï¼šå†…å­˜æ•°æ®åº“ä¸ç¼“å­˜ä¹‹ç‹](../æ•°æ®åº“/ã€æ•°æ®åº“ã€‘Redisè¯¦è§£ï¼šå†…å­˜æ•°æ®åº“ä¸ç¼“å­˜ä¹‹ç‹.md)
   - [ã€MySQLã€‘MySQLæ€§èƒ½ä¼˜åŒ–å…¨é¢æŒ‡å—](../æ•°æ®åº“/ã€MySQLã€‘MySQLæ€§èƒ½ä¼˜åŒ–å…¨é¢æŒ‡å—.md)
   - [ã€Javaã€‘MyBatisç”Ÿæ€ç³»ç»Ÿæ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–ç­–ç•¥è¯¦è§£](../Java/ã€Javaã€‘MyBatisç”Ÿæ€ç³»ç»Ÿæ€§èƒ½å¯¹æ¯”ä¸ä¼˜åŒ–ç­–ç•¥è¯¦è§£.md)

4. **å¼€æºé¡¹ç›®**
   - Ehcacheï¼šhttps://github.com/ehcache/ehcache3
   - Hazelcastï¼šhttps://github.com/hazelcast/hazelcast
   - Apache Igniteï¼šhttps://github.com/apache/ignite

---

> ğŸ’¡ **æç¤º**ï¼šç¼“å­˜ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦æ ¹æ®ä¸šåŠ¡ç‰¹ç‚¹å’Œç³»ç»Ÿè´Ÿè½½æƒ…å†µä¸æ–­è°ƒæ•´ç­–ç•¥ã€‚å»ºè®®åœ¨ç”Ÿäº§ç¯å¢ƒä¸­é€æ­¥å®æ–½ï¼Œå¹¶å»ºç«‹å®Œå–„çš„ç›‘æ§ä½“ç³»æ¥éªŒè¯ä¼˜åŒ–æ•ˆæœã€‚
