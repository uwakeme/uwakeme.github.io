---
title: ã€è½¯ä»¶åŠŸèƒ½è§£æã€‘å·¥ä½œæµç¨‹æ„å»ºå™¨æ·±åº¦è§£æï¼šå¯è§†åŒ–æµç¨‹è®¾è®¡ä¸è‡ªåŠ¨åŒ–æ‰§è¡Œå¼•æ“
categories: è½¯ä»¶åŠŸèƒ½è§£æ
date: 2025-01-15
tags:
  - å·¥ä½œæµç¨‹
  - è‡ªåŠ¨åŒ–
  - å¯è§†åŒ–è®¾è®¡
  - React Flow
  - Node.js
  - ä½ä»£ç å¹³å°
---

# å‰è¨€

åœ¨æ•°å­—åŒ–è½¬å‹çš„æµªæ½®ä¸­ï¼Œå·¥ä½œæµç¨‹è‡ªåŠ¨åŒ–å·²æˆä¸ºä¼ä¸šæå‡æ•ˆç‡çš„æ ¸å¿ƒé©±åŠ¨åŠ›ã€‚ä»ç®€å•çš„é‚®ä»¶é€šçŸ¥åˆ°å¤æ‚çš„ä¸šåŠ¡æµç¨‹ç¼–æ’ï¼Œå·¥ä½œæµç¨‹æ„å»ºå™¨æ­£åœ¨é‡æ–°å®šä¹‰æˆ‘ä»¬å¤„ç†é‡å¤æ€§ä»»åŠ¡çš„æ–¹å¼ã€‚æœ¬æ–‡å°†æ·±å…¥è§£æä¸€ä¸ªå®Œæ•´çš„å·¥ä½œæµç¨‹æ„å»ºå™¨ç³»ç»Ÿï¼Œä»å¯è§†åŒ–è®¾è®¡å™¨åˆ°åç«¯æ‰§è¡Œå¼•æ“ï¼Œä¸ºè¯»è€…æä¾›ä¸€ä¸ªå…¨é¢çš„æŠ€æœ¯å®ç°æŒ‡å—ã€‚

ä¸å¸‚é¢ä¸Šçš„ç†è®ºæ€§æ–‡ç« ä¸åŒï¼Œæœ¬æ–‡å°†æä¾›å®Œæ•´çš„ä»£ç å®ç°ï¼Œæ¯ä¸ªåŠŸèƒ½æ¨¡å—éƒ½æœ‰è¯¦ç»†çš„æŠ€æœ¯ç»†èŠ‚å’Œå®é™…å¯è¿è¡Œçš„ä»£ç ç¤ºä¾‹ã€‚é€šè¿‡æœ¬æ–‡ï¼Œè¯»è€…å°†æŒæ¡å¦‚ä½•æ„å»ºä¸€ä¸ªç±»ä¼¼Zapierã€Microsoft Power Automateçš„ä¼ä¸šçº§å·¥ä½œæµç¨‹è‡ªåŠ¨åŒ–å¹³å°ã€‚

## æ ¸å¿ƒåŠŸèƒ½æ¦‚è§ˆ

æˆ‘ä»¬å°†è¦æ„å»ºçš„å·¥ä½œæµç¨‹æ„å»ºå™¨åŒ…å«ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½ï¼š

**å‰ç«¯å¯è§†åŒ–è®¾è®¡å™¨**
- åŸºäºReact Flowçš„æ‹–æ‹½å¼æµç¨‹è®¾è®¡
- è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶ç³»ç»Ÿ
- å®æ—¶è¿æ¥éªŒè¯å’Œè·¯å¾„è§„åˆ’
- é…ç½®é¢æ¿å’Œå±æ€§ç¼–è¾‘å™¨

**åç«¯æ‰§è¡Œå¼•æ“**
- å¼‚æ­¥æµç¨‹æ‰§è¡Œå¼•æ“
- èŠ‚ç‚¹æ³¨å†Œè¡¨å’Œæ’ä»¶ç³»ç»Ÿ
- ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆæ¡†æ¶
- å®æ—¶çŠ¶æ€ç›‘æ§å’Œæ—¥å¿—è®°å½•

**ç¬¬ä¸‰æ–¹é›†æˆèƒ½åŠ›**
- Slackæ¶ˆæ¯é€šçŸ¥
- GitHubä»“åº“æ“ä½œ
- é‚®ä»¶å‘é€æœåŠ¡
- HTTP APIè°ƒç”¨

# ä¸€ã€ç³»ç»Ÿæ¶æ„è®¾è®¡

## ï¼ˆä¸€ï¼‰æ•´ä½“æŠ€æœ¯æ¶æ„

æˆ‘ä»¬çš„å·¥ä½œæµç¨‹æ„å»ºå™¨é‡‡ç”¨å‰åç«¯åˆ†ç¦»çš„æ¶æ„è®¾è®¡ï¼Œç¡®ä¿ç³»ç»Ÿçš„å¯æ‰©å±•æ€§å’Œç»´æŠ¤æ€§ï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    å‰ç«¯æ¶æ„å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  React + TypeScript + React Flow + Ant Design + Zustand    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ å¯è§†åŒ–è®¾è®¡å™¨ â”‚ â”‚ é…ç½®é¢æ¿    â”‚ â”‚ æ‰§è¡Œç›‘æ§    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                         WebSocket + REST API
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åç«¯æ¶æ„å±‚                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Node.js + TypeScript + Express + MongoDB + Redis         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ APIç½‘å…³     â”‚ â”‚ æ‰§è¡Œå¼•æ“    â”‚ â”‚ è¿æ¥å™¨ç®¡ç†  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ ä»»åŠ¡é˜Ÿåˆ—    â”‚ â”‚ çŠ¶æ€ç®¡ç†    â”‚ â”‚ æ—¥å¿—ç³»ç»Ÿ    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                         ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆ
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Slack API â”‚ GitHub API â”‚ SendGrid â”‚ Custom HTTP APIs      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ï¼ˆäºŒï¼‰æ ¸å¿ƒæ•°æ®æ¨¡å‹

**å·¥ä½œæµç¨‹å®šä¹‰æ¨¡å‹**

```typescript
interface WorkflowDefinition {
  id: string;
  name: string;
  description: string;
  version: string;
  status: 'draft' | 'active' | 'inactive';
  
  // èŠ‚ç‚¹å®šä¹‰
  nodes: WorkflowNode[];
  
  // è¿æ¥å®šä¹‰
  edges: WorkflowEdge[];
  
  // è§¦å‘å™¨é…ç½®
  trigger: {
    type: 'webhook' | 'schedule' | 'manual';
    config: any;
  };
  
  // å…¨å±€å˜é‡
  variables: Record<string, any>;
  
  // å…ƒæ•°æ®
  metadata: {
    createdAt: Date;
    updatedAt: Date;
    createdBy: string;
    tags: string[];
  };
}

interface WorkflowNode {
  id: string;
  type: string;
  position: { x: number; y: number };
  data: {
    label: string;
    config: any;
    inputs: Record<string, any>;
    outputs: Record<string, any>;
  };
}

interface WorkflowEdge {
  id: string;
  source: string;
  target: string;
  sourceHandle?: string;
  targetHandle?: string;
  type?: string;
}
```

**æ‰§è¡Œå®ä¾‹æ¨¡å‹**

```typescript
interface WorkflowInstance {
  id: string;
  workflowId: string;
  status: 'running' | 'completed' | 'failed' | 'cancelled';
  
  // è§¦å‘æ•°æ®
  triggerData: any;
  
  // æ‰§è¡Œæ—¥å¿—
  executionLog: ExecutionLogEntry[];
  
  // æ—¶é—´ä¿¡æ¯
  startTime: Date;
  endTime?: Date;
  duration?: number;
  
  // é”™è¯¯ä¿¡æ¯
  error?: {
    message: string;
    stack?: string;
    nodeId?: string;
  };
}

interface ExecutionLogEntry {
  nodeId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startTime: Date;
  endTime?: Date;
  input?: any;
  output?: any;
  error?: string;
}
```

# äºŒã€å‰ç«¯å¯è§†åŒ–è®¾è®¡å™¨å®ç°

## ï¼ˆä¸€ï¼‰React Flowé›†æˆä¸åŸºç¡€è®¾ç½®

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æ­å»ºåŸºäºReact Flowçš„å¯è§†åŒ–è®¾è®¡å™¨åŸºç¡€æ¡†æ¶ï¼š

**é¡¹ç›®åˆå§‹åŒ–å’Œä¾èµ–å®‰è£…**

```bash
# åˆ›å»ºReacté¡¹ç›®
npx create-react-app workflow-builder --template typescript
cd workflow-builder

# å®‰è£…æ ¸å¿ƒä¾èµ–
npm install reactflow antd zustand @tanstack/react-query
npm install axios socket.io-client
npm install @types/node --save-dev

# å®‰è£…å›¾æ ‡åº“
npm install @ant-design/icons
```

**ä¸»è®¾è®¡å™¨ç»„ä»¶å®ç°**

```tsx
// src/components/WorkflowDesigner.tsx
import React, { useCallback, useState, useRef } from 'react';
import ReactFlow, {
  Node,
  Edge,
  addEdge,
  Connection,
  useNodesState,
  useEdgesState,
  Controls,
  MiniMap,
  Background,
  BackgroundVariant,
  ReactFlowProvider,
  ReactFlowInstance,
} from 'reactflow';
import { Layout, Button, message, Drawer } from 'antd';
import { SaveOutlined, PlayCircleOutlined, SettingOutlined } from '@ant-design/icons';

// å¯¼å…¥è‡ªå®šä¹‰ç»„ä»¶
import NodePanel from './panels/NodePanel';
import ConfigPanel from './panels/ConfigPanel';
import ExecutionPanel from './panels/ExecutionPanel';
import { useWorkflowStore } from '../stores/workflowStore';
import { useSocketConnection } from '../hooks/useSocketConnection';

// å¯¼å…¥è‡ªå®šä¹‰èŠ‚ç‚¹ç±»å‹
import TriggerNode from './nodes/TriggerNode';
import ActionNode from './nodes/ActionNode';
import ConditionNode from './nodes/ConditionNode';
import TransformNode from './nodes/TransformNode';

import 'reactflow/dist/style.css';
import './WorkflowDesigner.css';

const { Sider, Content } = Layout;

// æ³¨å†Œè‡ªå®šä¹‰èŠ‚ç‚¹ç±»å‹
const nodeTypes = {
  trigger: TriggerNode,
  action: ActionNode,
  condition: ConditionNode,
  transform: TransformNode,
};

// åˆå§‹èŠ‚ç‚¹å’Œè¾¹
const initialNodes: Node[] = [];
const initialEdges: Edge[] = [];

const WorkflowDesigner: React.FC = () => {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
  const [selectedNode, setSelectedNode] = useState<Node | null>(null);
  const [configDrawerOpen, setConfigDrawerOpen] = useState(false);
  const [executionDrawerOpen, setExecutionDrawerOpen] = useState(false);
  
  const reactFlowWrapper = useRef<HTMLDivElement>(null);
  const [reactFlowInstance, setReactFlowInstance] = useState<ReactFlowInstance | null>(null);

  // çŠ¶æ€ç®¡ç†
  const {
    currentWorkflow,
    saveWorkflow,
    executeWorkflow,
    isLoading,
    executionStatus
  } = useWorkflowStore();

  // WebSocketè¿æ¥ç”¨äºå®æ—¶çŠ¶æ€æ›´æ–°
  const { isConnected } = useSocketConnection();

  // å¤„ç†èŠ‚ç‚¹è¿æ¥
  const onConnect = useCallback(
    (params: Connection) => {
      // éªŒè¯è¿æ¥çš„æœ‰æ•ˆæ€§
      if (!isValidConnection(params, nodes)) {
        message.error('æ— æ•ˆçš„è¿æ¥ï¼šä¸èƒ½åˆ›å»ºå¾ªç¯æˆ–è¿æ¥åˆ°ç›¸åŒç±»å‹çš„ç«¯å£');
        return;
      }

      const newEdge: Edge = {
        ...params,
        id: `edge-${params.source}-${params.target}`,
        type: 'smoothstep',
        animated: true,
        style: { stroke: '#1890ff', strokeWidth: 2 },
      };
      
      setEdges((eds) => addEdge(newEdge, eds));
    },
    [setEdges, nodes]
  );

  // å¤„ç†èŠ‚ç‚¹é€‰æ‹©
  const onNodeClick = useCallback((event: React.MouseEvent, node: Node) => {
    setSelectedNode(node);
    setConfigDrawerOpen(true);
  }, []);

  // å¤„ç†æ‹–æ‹½æ·»åŠ èŠ‚ç‚¹
  const onDragOver = useCallback((event: React.DragEvent) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  }, []);

  const onDrop = useCallback(
    (event: React.DragEvent) => {
      event.preventDefault();

      if (!reactFlowWrapper.current || !reactFlowInstance) {
        return;
      }

      const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
      const type = event.dataTransfer.getData('application/reactflow');
      
      if (!type) {
        return;
      }

      const position = reactFlowInstance.project({
        x: event.clientX - reactFlowBounds.left,
        y: event.clientY - reactFlowBounds.top,
      });

      const newNode: Node = {
        id: generateNodeId(),
        type,
        position,
        data: {
          label: getNodeLabel(type),
          config: getDefaultNodeConfig(type),
          isConfigured: false,
        },
      };

      setNodes((nds) => nds.concat(newNode));
    },
    [reactFlowInstance, setNodes]
  );

  // ä¿å­˜å·¥ä½œæµç¨‹
  const handleSave = async () => {
    try {
      // éªŒè¯å·¥ä½œæµç¨‹
      const validation = validateWorkflow(nodes, edges);
      if (!validation.isValid) {
        message.error(`å·¥ä½œæµç¨‹éªŒè¯å¤±è´¥: ${validation.errors.join(', ')}`);
        return;
      }

      const workflowData = {
        nodes,
        edges,
        name: currentWorkflow?.name || 'æœªå‘½åå·¥ä½œæµç¨‹',
        description: currentWorkflow?.description || '',
        version: '1.0.0',
      };

      await saveWorkflow(workflowData);
      message.success('å·¥ä½œæµç¨‹ä¿å­˜æˆåŠŸ');
    } catch (error) {
      message.error('ä¿å­˜å¤±è´¥: ' + (error as Error).message);
    }
  };

  // æ‰§è¡Œå·¥ä½œæµç¨‹
  const handleExecute = async () => {
    try {
      if (!currentWorkflow?.id) {
        message.warning('è¯·å…ˆä¿å­˜å·¥ä½œæµç¨‹');
        return;
      }

      // éªŒè¯å·¥ä½œæµç¨‹é…ç½®
      const validation = validateWorkflowExecution(nodes, edges);
      if (!validation.isValid) {
        message.error(`æ‰§è¡ŒéªŒè¯å¤±è´¥: ${validation.errors.join(', ')}`);
        return;
      }

      await executeWorkflow(currentWorkflow.id, {});
      setExecutionDrawerOpen(true);
      message.success('å·¥ä½œæµç¨‹å¼€å§‹æ‰§è¡Œ');
    } catch (error) {
      message.error('æ‰§è¡Œå¤±è´¥: ' + (error as Error).message);
    }
  };

  // æ›´æ–°èŠ‚ç‚¹é…ç½®
  const handleNodeUpdate = useCallback((updatedNode: Node) => {
    setNodes((nds) =>
      nds.map((node) =>
        node.id === updatedNode.id ? updatedNode : node
      )
    );
    setSelectedNode(updatedNode);
  }, [setNodes]);

  return (
    <ReactFlowProvider>
      <Layout style={{ height: '100vh' }}>
        {/* å·¦ä¾§èŠ‚ç‚¹é¢æ¿ */}
        <Sider width={280} theme="light" style={{ borderRight: '1px solid #f0f0f0' }}>
          <NodePanel />
        </Sider>

        {/* ä¸»è®¾è®¡åŒºåŸŸ */}
        <Content>
          {/* å·¥å…·æ  */}
          <div className="workflow-toolbar">
            <div className="toolbar-left">
              <Button
                type="primary"
                icon={<SaveOutlined />}
                onClick={handleSave}
                loading={isLoading}
              >
                ä¿å­˜
              </Button>
              <Button
                icon={<PlayCircleOutlined />}
                onClick={handleExecute}
                loading={isLoading}
                disabled={!currentWorkflow?.id}
              >
                æ‰§è¡Œ
              </Button>
            </div>
            
            <div className="toolbar-right">
              <Button
                icon={<SettingOutlined />}
                onClick={() => setExecutionDrawerOpen(true)}
                disabled={!executionStatus}
              >
                æ‰§è¡ŒçŠ¶æ€
              </Button>
              <div className="connection-status">
                <span className={`status-indicator ${isConnected ? 'connected' : 'disconnected'}`} />
                {isConnected ? 'å·²è¿æ¥' : 'æœªè¿æ¥'}
              </div>
            </div>
          </div>

          {/* React Flow ç”»å¸ƒ */}
          <div className="reactflow-wrapper" ref={reactFlowWrapper}>
            <ReactFlow
              nodes={nodes}
              edges={edges}
              onNodesChange={onNodesChange}
              onEdgesChange={onEdgesChange}
              onConnect={onConnect}
              onNodeClick={onNodeClick}
              onDrop={onDrop}
              onDragOver={onDragOver}
              onInit={setReactFlowInstance}
              nodeTypes={nodeTypes}
              fitView
              attributionPosition="top-right"
            >
              <Controls />
              <MiniMap />
              <Background variant={BackgroundVariant.Dots} gap={12} size={1} />
            </ReactFlow>
          </div>
        </Content>

        {/* é…ç½®é¢æ¿æŠ½å±‰ */}
        <Drawer
          title="èŠ‚ç‚¹é…ç½®"
          placement="right"
          width={400}
          open={configDrawerOpen}
          onClose={() => setConfigDrawerOpen(false)}
          destroyOnClose
        >
          {selectedNode && (
            <ConfigPanel
              node={selectedNode}
              onUpdate={handleNodeUpdate}
              onClose={() => setConfigDrawerOpen(false)}
            />
          )}
        </Drawer>

        {/* æ‰§è¡ŒçŠ¶æ€é¢æ¿ */}
        <Drawer
          title="æ‰§è¡ŒçŠ¶æ€"
          placement="right"
          width={500}
          open={executionDrawerOpen}
          onClose={() => setExecutionDrawerOpen(false)}
        >
          <ExecutionPanel />
        </Drawer>
      </Layout>
    </ReactFlowProvider>
  );
};

// è¾…åŠ©å‡½æ•°
function generateNodeId(): string {
  return `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

function getNodeLabel(type: string): string {
  const labels = {
    trigger: 'è§¦å‘å™¨',
    action: 'åŠ¨ä½œ',
    condition: 'æ¡ä»¶',
    transform: 'è½¬æ¢',
  };
  return labels[type] || 'æœªçŸ¥èŠ‚ç‚¹';
}

function getDefaultNodeConfig(type: string): any {
  const configs = {
    trigger: { type: 'manual' },
    action: { type: 'slack', message: '' },
    condition: { operator: 'equals', value: '' },
    transform: { script: '' },
  };
  return configs[type] || {};
}

function isValidConnection(connection: Connection, nodes: Node[]): boolean {
  // æ£€æŸ¥æ˜¯å¦ä¼šåˆ›å»ºå¾ªç¯
  // æ£€æŸ¥è¿æ¥ç±»å‹æ˜¯å¦åŒ¹é…
  // è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥æœ‰æ›´å¤æ‚çš„éªŒè¯é€»è¾‘
  return connection.source !== connection.target;
}

function validateWorkflow(nodes: Node[], edges: Edge[]): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // æ£€æŸ¥æ˜¯å¦æœ‰è§¦å‘å™¨èŠ‚ç‚¹
  const triggerNodes = nodes.filter(node => node.type === 'trigger');
  if (triggerNodes.length === 0) {
    errors.push('å·¥ä½œæµç¨‹å¿…é¡»åŒ…å«è‡³å°‘ä¸€ä¸ªè§¦å‘å™¨èŠ‚ç‚¹');
  }
  
  // æ£€æŸ¥èŠ‚ç‚¹é…ç½®
  for (const node of nodes) {
    if (!node.data.isConfigured) {
      errors.push(`èŠ‚ç‚¹ "${node.data.label}" å°šæœªé…ç½®`);
    }
  }
  
  return { isValid: errors.length === 0, errors };
}

function validateWorkflowExecution(nodes: Node[], edges: Edge[]): { isValid: boolean; errors: string[] } {
  const errors: string[] = [];
  
  // æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹æ˜¯å¦å·²é…ç½®
  for (const node of nodes) {
    if (!node.data.isConfigured) {
      errors.push(`èŠ‚ç‚¹ "${node.data.label}" å°šæœªé…ç½®å®Œæˆ`);
    }
  }
  
  return { isValid: errors.length === 0, errors };
}

export default WorkflowDesigner;
```

è¿™ä¸ªåŸºç¡€çš„è®¾è®¡å™¨ç»„ä»¶æä¾›äº†ï¼š

1. **æ‹–æ‹½å¼èŠ‚ç‚¹æ·»åŠ **ï¼šä»å·¦ä¾§é¢æ¿æ‹–æ‹½èŠ‚ç‚¹åˆ°ç”»å¸ƒ
2. **èŠ‚ç‚¹è¿æ¥**ï¼šé€šè¿‡æ‹–æ‹½åˆ›å»ºèŠ‚ç‚¹é—´çš„è¿æ¥
3. **é…ç½®ç®¡ç†**ï¼šç‚¹å‡»èŠ‚ç‚¹æ‰“å¼€é…ç½®é¢æ¿
4. **å·¥ä½œæµç¨‹ä¿å­˜å’Œæ‰§è¡Œ**ï¼šé›†æˆäº†ä¿å­˜å’Œæ‰§è¡ŒåŠŸèƒ½
5. **å®æ—¶çŠ¶æ€ç›‘æ§**ï¼šé€šè¿‡WebSocketè¿æ¥æ˜¾ç¤ºæ‰§è¡ŒçŠ¶æ€

## ï¼ˆäºŒï¼‰è‡ªå®šä¹‰èŠ‚ç‚¹ç»„ä»¶å®ç°

**è§¦å‘å™¨èŠ‚ç‚¹ç»„ä»¶**

```tsx
// src/components/nodes/TriggerNode.tsx
import React from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Card, Tag, Button, Space } from 'antd';
import { PlayCircleOutlined, SettingOutlined, ClockCircleOutlined } from '@ant-design/icons';

interface TriggerNodeData {
  label: string;
  config: {
    type: 'webhook' | 'schedule' | 'manual';
    webhookUrl?: string;
    cronExpression?: string;
  };
  isConfigured: boolean;
  status?: 'idle' | 'running' | 'success' | 'error';
}

const TriggerNode: React.FC<NodeProps<TriggerNodeData>> = ({
  data,
  selected,
  id
}) => {
  const getTriggerIcon = () => {
    switch (data.config.type) {
      case 'webhook':
        return 'ğŸ”—';
      case 'schedule':
        return <ClockCircleOutlined />;
      case 'manual':
        return <PlayCircleOutlined />;
      default:
        return 'â–¶ï¸';
    }
  };

  const getTriggerDescription = () => {
    switch (data.config.type) {
      case 'webhook':
        return 'Webhookè§¦å‘';
      case 'schedule':
        return `å®šæ—¶è§¦å‘: ${data.config.cronExpression || 'æœªè®¾ç½®'}`;
      case 'manual':
        return 'æ‰‹åŠ¨è§¦å‘';
      default:
        return 'æœªé…ç½®';
    }
  };

  const getStatusColor = () => {
    if (!data.isConfigured) return '#faad14';
    switch (data.status) {
      case 'running': return '#1890ff';
      case 'success': return '#52c41a';
      case 'error': return '#ff4d4f';
      default: return '#52c41a';
    }
  };

  return (
    <div className="custom-node trigger-node">
      <Card
        size="small"
        style={{
          minWidth: 200,
          borderColor: selected ? '#1890ff' : getStatusColor(),
          borderWidth: 2,
          boxShadow: selected ? '0 0 0 2px rgba(24, 144, 255, 0.2)' : undefined
        }}
        bodyStyle={{ padding: '12px' }}
      >
        <div className="node-header">
          <Space>
            <span style={{ fontSize: '16px' }}>{getTriggerIcon()}</span>
            <div>
              <div className="node-title">{data.label}</div>
              <div className="node-description">{getTriggerDescription()}</div>
            </div>
          </Space>

          <div className="node-status">
            <Tag color={data.isConfigured ? 'success' : 'warning'}>
              {data.isConfigured ? 'å·²é…ç½®' : 'æœªé…ç½®'}
            </Tag>
          </div>
        </div>

        {data.status === 'running' && (
          <div className="node-progress">
            <div className="progress-bar" />
          </div>
        )}
      </Card>

      {/* è¾“å‡ºè¿æ¥ç‚¹ */}
      <Handle
        type="source"
        position={Position.Right}
        id="output"
        style={{
          background: '#1890ff',
          border: '2px solid white',
          width: 12,
          height: 12
        }}
      />
    </div>
  );
};

export default TriggerNode;
```

**åŠ¨ä½œèŠ‚ç‚¹ç»„ä»¶**

```tsx
// src/components/nodes/ActionNode.tsx
import React from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Card, Tag, Avatar, Space, Progress } from 'antd';
import {
  MessageOutlined,
  MailOutlined,
  GithubOutlined,
  ApiOutlined
} from '@ant-design/icons';

interface ActionNodeData {
  label: string;
  config: {
    type: 'slack' | 'email' | 'github' | 'http';
    [key: string]: any;
  };
  isConfigured: boolean;
  status?: 'idle' | 'running' | 'success' | 'error';
  progress?: number;
}

const ActionNode: React.FC<NodeProps<ActionNodeData>> = ({
  data,
  selected
}) => {
  const getActionIcon = () => {
    const iconProps = { style: { color: '#1890ff' } };

    switch (data.config.type) {
      case 'slack':
        return <MessageOutlined {...iconProps} />;
      case 'email':
        return <MailOutlined {...iconProps} />;
      case 'github':
        return <GithubOutlined {...iconProps} />;
      case 'http':
        return <ApiOutlined {...iconProps} />;
      default:
        return <ApiOutlined {...iconProps} />;
    }
  };

  const getActionName = () => {
    switch (data.config.type) {
      case 'slack':
        return 'Slackæ¶ˆæ¯';
      case 'email':
        return 'å‘é€é‚®ä»¶';
      case 'github':
        return 'GitHubæ“ä½œ';
      case 'http':
        return 'HTTPè¯·æ±‚';
      default:
        return 'åŠ¨ä½œ';
    }
  };

  const getActionDescription = () => {
    switch (data.config.type) {
      case 'slack':
        return `é¢‘é“: ${data.config.channel || 'æœªè®¾ç½®'}`;
      case 'email':
        return `æ”¶ä»¶äºº: ${data.config.to || 'æœªè®¾ç½®'}`;
      case 'github':
        return `ä»“åº“: ${data.config.repo || 'æœªè®¾ç½®'}`;
      case 'http':
        return `${data.config.method || 'GET'} ${data.config.url || 'æœªè®¾ç½®'}`;
      default:
        return 'æœªé…ç½®';
    }
  };

  const getBorderColor = () => {
    if (!data.isConfigured) return '#faad14';
    if (selected) return '#1890ff';

    switch (data.status) {
      case 'running': return '#1890ff';
      case 'success': return '#52c41a';
      case 'error': return '#ff4d4f';
      default: return '#d9d9d9';
    }
  };

  return (
    <div className="custom-node action-node">
      {/* è¾“å…¥è¿æ¥ç‚¹ */}
      <Handle
        type="target"
        position={Position.Left}
        id="input"
        style={{
          background: '#1890ff',
          border: '2px solid white',
          width: 12,
          height: 12
        }}
      />

      <Card
        size="small"
        style={{
          minWidth: 220,
          borderColor: getBorderColor(),
          borderWidth: 2,
          boxShadow: selected ? '0 0 0 2px rgba(24, 144, 255, 0.2)' : undefined
        }}
        bodyStyle={{ padding: '12px' }}
      >
        <div className="node-header">
          <Space>
            <Avatar
              size="small"
              icon={getActionIcon()}
              style={{ backgroundColor: '#f0f0f0' }}
            />
            <div>
              <div className="node-title">{getActionName()}</div>
              <div className="node-description">{getActionDescription()}</div>
            </div>
          </Space>

          <Tag color={data.isConfigured ? 'success' : 'warning'}>
            {data.isConfigured ? 'å·²é…ç½®' : 'æœªé…ç½®'}
          </Tag>
        </div>

        {/* æ‰§è¡Œè¿›åº¦ */}
        {data.status === 'running' && data.progress !== undefined && (
          <div style={{ marginTop: 8 }}>
            <Progress
              percent={data.progress}
              size="small"
              status="active"
              showInfo={false}
            />
          </div>
        )}

        {/* çŠ¶æ€æŒ‡ç¤ºå™¨ */}
        {data.status && data.status !== 'idle' && (
          <div className={`status-indicator status-${data.status}`} />
        )}
      </Card>

      {/* è¾“å‡ºè¿æ¥ç‚¹ */}
      <Handle
        type="source"
        position={Position.Right}
        id="output"
        style={{
          background: '#1890ff',
          border: '2px solid white',
          width: 12,
          height: 12
        }}
      />
    </div>
  );
};

export default ActionNode;
```

**æ¡ä»¶èŠ‚ç‚¹ç»„ä»¶**

```tsx
// src/components/nodes/ConditionNode.tsx
import React from 'react';
import { Handle, Position, NodeProps } from 'reactflow';
import { Card, Tag, Space } from 'antd';
import { BranchesOutlined } from '@ant-design/icons';

interface ConditionNodeData {
  label: string;
  config: {
    field: string;
    operator: 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'contains';
    value: any;
  };
  isConfigured: boolean;
  status?: 'idle' | 'running' | 'success' | 'error';
  lastResult?: boolean;
}

const ConditionNode: React.FC<NodeProps<ConditionNodeData>> = ({
  data,
  selected
}) => {
  const getOperatorText = () => {
    const operators = {
      equals: 'ç­‰äº',
      not_equals: 'ä¸ç­‰äº',
      greater_than: 'å¤§äº',
      less_than: 'å°äº',
      contains: 'åŒ…å«'
    };
    return operators[data.config.operator] || 'æœªè®¾ç½®';
  };

  const getConditionDescription = () => {
    if (!data.isConfigured) return 'æœªé…ç½®æ¡ä»¶';

    return `${data.config.field} ${getOperatorText()} ${data.config.value}`;
  };

  const getBorderColor = () => {
    if (!data.isConfigured) return '#faad14';
    if (selected) return '#1890ff';

    switch (data.status) {
      case 'running': return '#1890ff';
      case 'success': return '#52c41a';
      case 'error': return '#ff4d4f';
      default: return '#722ed1';
    }
  };

  return (
    <div className="custom-node condition-node">
      {/* è¾“å…¥è¿æ¥ç‚¹ */}
      <Handle
        type="target"
        position={Position.Left}
        id="input"
        style={{
          background: '#722ed1',
          border: '2px solid white',
          width: 12,
          height: 12
        }}
      />

      <Card
        size="small"
        style={{
          minWidth: 200,
          borderColor: getBorderColor(),
          borderWidth: 2,
          boxShadow: selected ? '0 0 0 2px rgba(114, 46, 209, 0.2)' : undefined
        }}
        bodyStyle={{ padding: '12px' }}
      >
        <div className="node-header">
          <Space>
            <BranchesOutlined style={{ color: '#722ed1', fontSize: '16px' }} />
            <div>
              <div className="node-title">æ¡ä»¶åˆ¤æ–­</div>
              <div className="node-description">{getConditionDescription()}</div>
            </div>
          </Space>

          <Tag color={data.isConfigured ? 'success' : 'warning'}>
            {data.isConfigured ? 'å·²é…ç½®' : 'æœªé…ç½®'}
          </Tag>
        </div>

        {/* æ˜¾ç¤ºä¸Šæ¬¡æ‰§è¡Œç»“æœ */}
        {data.lastResult !== undefined && (
          <div style={{ marginTop: 8, textAlign: 'center' }}>
            <Tag color={data.lastResult ? 'success' : 'error'}>
              ä¸Šæ¬¡ç»“æœ: {data.lastResult ? 'çœŸ' : 'å‡'}
            </Tag>
          </div>
        )}
      </Card>

      {/* è¾“å‡ºè¿æ¥ç‚¹ - Trueåˆ†æ”¯ */}
      <Handle
        type="source"
        position={Position.Bottom}
        id="true"
        style={{
          background: '#52c41a',
          border: '2px solid white',
          width: 12,
          height: 12,
          left: '25%'
        }}
      />

      {/* è¾“å‡ºè¿æ¥ç‚¹ - Falseåˆ†æ”¯ */}
      <Handle
        type="source"
        position={Position.Bottom}
        id="false"
        style={{
          background: '#ff4d4f',
          border: '2px solid white',
          width: 12,
          height: 12,
          left: '75%'
        }}
      />

      {/* åˆ†æ”¯æ ‡ç­¾ */}
      <div className="branch-labels">
        <span className="branch-label true-label">çœŸ</span>
        <span className="branch-label false-label">å‡</span>
      </div>
    </div>
  );
};

export default ConditionNode;
```

## ï¼ˆä¸‰ï¼‰çŠ¶æ€ç®¡ç†ä¸APIé›†æˆ

**ZustandçŠ¶æ€ç®¡ç†å®ç°**

```tsx
// src/stores/workflowStore.ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { Node, Edge } from 'reactflow';
import { workflowAPI } from '../services/api';

interface Workflow {
  id: string;
  name: string;
  description: string;
  nodes: Node[];
  edges: Edge[];
  status: 'draft' | 'active' | 'inactive';
  version: string;
  createdAt: string;
  updatedAt: string;
}

interface WorkflowExecution {
  id: string;
  workflowId: string;
  status: 'running' | 'completed' | 'failed' | 'cancelled';
  startTime: string;
  endTime?: string;
  logs: ExecutionLog[];
  error?: string;
}

interface ExecutionLog {
  nodeId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  startTime: string;
  endTime?: string;
  input?: any;
  output?: any;
  error?: string;
}

interface WorkflowStore {
  // çŠ¶æ€
  workflows: Workflow[];
  currentWorkflow: Workflow | null;
  executionStatus: WorkflowExecution | null;
  isLoading: boolean;
  error: string | null;

  // åŠ¨ä½œ
  loadWorkflows: () => Promise<void>;
  loadWorkflow: (id: string) => Promise<void>;
  saveWorkflow: (data: Partial<Workflow>) => Promise<void>;
  deleteWorkflow: (id: string) => Promise<void>;
  executeWorkflow: (id: string, triggerData: any) => Promise<void>;
  stopExecution: (executionId: string) => Promise<void>;
  updateExecutionStatus: (execution: WorkflowExecution) => void;
  setCurrentWorkflow: (workflow: Workflow | null) => void;
  setError: (error: string | null) => void;
}

export const useWorkflowStore = create<WorkflowStore>()(
  devtools(
    (set, get) => ({
      // åˆå§‹çŠ¶æ€
      workflows: [],
      currentWorkflow: null,
      executionStatus: null,
      isLoading: false,
      error: null,

      // åŠ è½½å·¥ä½œæµç¨‹åˆ—è¡¨
      loadWorkflows: async () => {
        set({ isLoading: true, error: null });
        try {
          const workflows = await workflowAPI.getWorkflows();
          set({ workflows, isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'åŠ è½½å·¥ä½œæµç¨‹å¤±è´¥',
            isLoading: false
          });
        }
      },

      // åŠ è½½å•ä¸ªå·¥ä½œæµç¨‹
      loadWorkflow: async (id: string) => {
        set({ isLoading: true, error: null });
        try {
          const workflow = await workflowAPI.getWorkflow(id);
          set({ currentWorkflow: workflow, isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'åŠ è½½å·¥ä½œæµç¨‹å¤±è´¥',
            isLoading: false
          });
        }
      },

      // ä¿å­˜å·¥ä½œæµç¨‹
      saveWorkflow: async (data: Partial<Workflow>) => {
        set({ isLoading: true, error: null });
        try {
          const { currentWorkflow } = get();

          let savedWorkflow: Workflow;
          if (currentWorkflow?.id) {
            // æ›´æ–°ç°æœ‰å·¥ä½œæµç¨‹
            savedWorkflow = await workflowAPI.updateWorkflow(currentWorkflow.id, data);
          } else {
            // åˆ›å»ºæ–°å·¥ä½œæµç¨‹
            savedWorkflow = await workflowAPI.createWorkflow(data);
          }

          set({
            currentWorkflow: savedWorkflow,
            isLoading: false
          });

          // æ›´æ–°å·¥ä½œæµç¨‹åˆ—è¡¨
          const { workflows } = get();
          const updatedWorkflows = currentWorkflow?.id
            ? workflows.map(w => w.id === savedWorkflow.id ? savedWorkflow : w)
            : [...workflows, savedWorkflow];

          set({ workflows: updatedWorkflows });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'ä¿å­˜å·¥ä½œæµç¨‹å¤±è´¥',
            isLoading: false
          });
          throw error;
        }
      },

      // åˆ é™¤å·¥ä½œæµç¨‹
      deleteWorkflow: async (id: string) => {
        set({ isLoading: true, error: null });
        try {
          await workflowAPI.deleteWorkflow(id);

          const { workflows, currentWorkflow } = get();
          const updatedWorkflows = workflows.filter(w => w.id !== id);

          set({
            workflows: updatedWorkflows,
            currentWorkflow: currentWorkflow?.id === id ? null : currentWorkflow,
            isLoading: false
          });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'åˆ é™¤å·¥ä½œæµç¨‹å¤±è´¥',
            isLoading: false
          });
          throw error;
        }
      },

      // æ‰§è¡Œå·¥ä½œæµç¨‹
      executeWorkflow: async (id: string, triggerData: any) => {
        set({ isLoading: true, error: null });
        try {
          const execution = await workflowAPI.executeWorkflow(id, triggerData);
          set({
            executionStatus: execution,
            isLoading: false
          });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'æ‰§è¡Œå·¥ä½œæµç¨‹å¤±è´¥',
            isLoading: false
          });
          throw error;
        }
      },

      // åœæ­¢æ‰§è¡Œ
      stopExecution: async (executionId: string) => {
        set({ isLoading: true, error: null });
        try {
          await workflowAPI.stopExecution(executionId);
          set({ isLoading: false });
        } catch (error) {
          set({
            error: error instanceof Error ? error.message : 'åœæ­¢æ‰§è¡Œå¤±è´¥',
            isLoading: false
          });
          throw error;
        }
      },

      // æ›´æ–°æ‰§è¡ŒçŠ¶æ€ï¼ˆé€šè¿‡WebSocketï¼‰
      updateExecutionStatus: (execution: WorkflowExecution) => {
        set({ executionStatus: execution });
      },

      // è®¾ç½®å½“å‰å·¥ä½œæµç¨‹
      setCurrentWorkflow: (workflow: Workflow | null) => {
        set({ currentWorkflow: workflow });
      },

      // è®¾ç½®é”™è¯¯ä¿¡æ¯
      setError: (error: string | null) => {
        set({ error });
      },
    }),
    {
      name: 'workflow-store',
    }
  )
);
```

**APIæœåŠ¡å±‚å®ç°**

```typescript
// src/services/api.ts
import axios, { AxiosInstance, AxiosResponse } from 'axios';

class WorkflowAPI {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: process.env.REACT_APP_API_BASE_URL || 'http://localhost:3001/api',
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // è¯·æ±‚æ‹¦æˆªå™¨ - æ·»åŠ è®¤è¯token
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('authToken');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // å“åº”æ‹¦æˆªå™¨ - ç»Ÿä¸€é”™è¯¯å¤„ç†
    this.client.interceptors.response.use(
      (response: AxiosResponse) => response.data,
      (error) => {
        if (error.response?.status === 401) {
          // å¤„ç†è®¤è¯å¤±è´¥
          localStorage.removeItem('authToken');
          window.location.href = '/login';
        }
        return Promise.reject(error.response?.data || error);
      }
    );
  }

  // å·¥ä½œæµç¨‹ç›¸å…³API
  async getWorkflows(): Promise<Workflow[]> {
    return this.client.get('/workflows');
  }

  async getWorkflow(id: string): Promise<Workflow> {
    return this.client.get(`/workflows/${id}`);
  }

  async createWorkflow(data: Partial<Workflow>): Promise<Workflow> {
    return this.client.post('/workflows', data);
  }

  async updateWorkflow(id: string, data: Partial<Workflow>): Promise<Workflow> {
    return this.client.put(`/workflows/${id}`, data);
  }

  async deleteWorkflow(id: string): Promise<void> {
    return this.client.delete(`/workflows/${id}`);
  }

  // æ‰§è¡Œç›¸å…³API
  async executeWorkflow(id: string, triggerData: any): Promise<WorkflowExecution> {
    return this.client.post(`/workflows/${id}/execute`, { triggerData });
  }

  async getExecution(executionId: string): Promise<WorkflowExecution> {
    return this.client.get(`/executions/${executionId}`);
  }

  async stopExecution(executionId: string): Promise<void> {
    return this.client.post(`/executions/${executionId}/stop`);
  }

  async getExecutionLogs(executionId: string): Promise<ExecutionLog[]> {
    return this.client.get(`/executions/${executionId}/logs`);
  }

  // è¿æ¥å™¨ç›¸å…³API
  async getConnectors(): Promise<Connector[]> {
    return this.client.get('/connectors');
  }

  async createConnector(data: any): Promise<Connector> {
    return this.client.post('/connectors', data);
  }

  async testConnector(type: string, config: any): Promise<{ success: boolean; message?: string }> {
    return this.client.post('/connectors/test', { type, config });
  }

  // èŠ‚ç‚¹æ¨¡æ¿ç›¸å…³API
  async getNodeTemplates(): Promise<NodeTemplate[]> {
    return this.client.get('/node-templates');
  }
}

export const workflowAPI = new WorkflowAPI();
```

# ä¸‰ã€åç«¯æ‰§è¡Œå¼•æ“å®ç°

## ï¼ˆä¸€ï¼‰ExpressæœåŠ¡å™¨å’ŒåŸºç¡€æ¶æ„

**æœåŠ¡å™¨ä¸»æ–‡ä»¶**

```typescript
// server/src/app.ts
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import { createServer } from 'http';
import { Server as SocketIOServer } from 'socket.io';
import mongoose from 'mongoose';
import { config } from './config';
import { errorHandler, notFoundHandler } from './middleware/errorHandler';
import { authMiddleware } from './middleware/auth';
import { rateLimitMiddleware } from './middleware/rateLimit';

// è·¯ç”±å¯¼å…¥
import workflowRoutes from './routes/workflows';
import executionRoutes from './routes/executions';
import connectorRoutes from './routes/connectors';
import nodeTemplateRoutes from './routes/nodeTemplates';

// æœåŠ¡å¯¼å…¥
import { WorkflowEngine } from './services/WorkflowEngine';
import { SocketManager } from './services/SocketManager';

class Application {
  public app: express.Application;
  public server: any;
  public io: SocketIOServer;
  private workflowEngine: WorkflowEngine;
  private socketManager: SocketManager;

  constructor() {
    this.app = express();
    this.server = createServer(this.app);
    this.io = new SocketIOServer(this.server, {
      cors: {
        origin: process.env.FRONTEND_URL || "http://localhost:3000",
        methods: ["GET", "POST"]
      }
    });

    this.initializeDatabase();
    this.initializeMiddleware();
    this.initializeRoutes();
    this.initializeServices();
    this.initializeErrorHandling();
  }

  private async initializeDatabase(): Promise<void> {
    try {
      await mongoose.connect(config.database.uri, {
        useNewUrlParser: true,
        useUnifiedTopology: true,
      });
      console.log('âœ… æ•°æ®åº“è¿æ¥æˆåŠŸ');
    } catch (error) {
      console.error('âŒ æ•°æ®åº“è¿æ¥å¤±è´¥:', error);
      process.exit(1);
    }
  }

  private initializeMiddleware(): void {
    // å®‰å…¨ä¸­é—´ä»¶
    this.app.use(helmet());
    this.app.use(cors({
      origin: process.env.FRONTEND_URL || "http://localhost:3000",
      credentials: true
    }));
    this.app.use(compression());

    // åŸºç¡€ä¸­é—´ä»¶
    this.app.use(express.json({ limit: '10mb' }));
    this.app.use(express.urlencoded({ extended: true }));

    // é™æµä¸­é—´ä»¶
    this.app.use(rateLimitMiddleware);

    // è®¤è¯ä¸­é—´ä»¶ï¼ˆé™¤äº†å…¬å¼€è·¯ç”±ï¼‰
    this.app.use('/api', authMiddleware);

    // è¯·æ±‚æ—¥å¿—
    this.app.use((req, res, next) => {
      console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
      next();
    });
  }

  private initializeRoutes(): void {
    // APIè·¯ç”±
    this.app.use('/api/workflows', workflowRoutes);
    this.app.use('/api/executions', executionRoutes);
    this.app.use('/api/connectors', connectorRoutes);
    this.app.use('/api/node-templates', nodeTemplateRoutes);

    // å¥åº·æ£€æŸ¥
    this.app.get('/health', (req, res) => {
      res.json({
        status: 'ok',
        timestamp: new Date().toISOString(),
        uptime: process.uptime()
      });
    });
  }

  private initializeServices(): void {
    // åˆå§‹åŒ–å·¥ä½œæµç¨‹æ‰§è¡Œå¼•æ“
    this.workflowEngine = new WorkflowEngine();

    // åˆå§‹åŒ–Socketç®¡ç†å™¨
    this.socketManager = new SocketManager(this.io);

    // è¿æ¥æ‰§è¡Œå¼•æ“å’ŒSocketç®¡ç†å™¨
    this.workflowEngine.on('workflow.started', (data) => {
      this.socketManager.broadcastExecutionUpdate(data);
    });

    this.workflowEngine.on('workflow.completed', (data) => {
      this.socketManager.broadcastExecutionUpdate(data);
    });

    this.workflowEngine.on('workflow.failed', (data) => {
      this.socketManager.broadcastExecutionUpdate(data);
    });

    this.workflowEngine.on('node.started', (data) => {
      this.socketManager.broadcastNodeUpdate(data);
    });

    this.workflowEngine.on('node.completed', (data) => {
      this.socketManager.broadcastNodeUpdate(data);
    });

    this.workflowEngine.on('node.failed', (data) => {
      this.socketManager.broadcastNodeUpdate(data);
    });

    // å°†æœåŠ¡å®ä¾‹æ·»åŠ åˆ°appä¸­ï¼Œä¾›è·¯ç”±ä½¿ç”¨
    this.app.set('workflowEngine', this.workflowEngine);
    this.app.set('socketManager', this.socketManager);
  }

  private initializeErrorHandling(): void {
    this.app.use(notFoundHandler);
    this.app.use(errorHandler);
  }

  public listen(): void {
    const port = config.server.port;
    this.server.listen(port, () => {
      console.log(`ğŸš€ æœåŠ¡å™¨å¯åŠ¨æˆåŠŸï¼Œç«¯å£: ${port}`);
      console.log(`ğŸ“Š ç¯å¢ƒ: ${process.env.NODE_ENV || 'development'}`);
    });
  }
}

export default Application;
```

## ï¼ˆäºŒï¼‰å·¥ä½œæµç¨‹æ‰§è¡Œå¼•æ“æ ¸å¿ƒå®ç°

**æ‰§è¡Œå¼•æ“ä¸»ç±»**

```typescript
// server/src/services/WorkflowEngine.ts
import { EventEmitter } from 'events';
import { Queue } from 'bull';
import { WorkflowModel, WorkflowInstanceModel } from '../models';
import { NodeRegistry } from './NodeRegistry';
import { ConnectorManager } from './ConnectorManager';
import { Logger } from '../utils/logger';

interface ExecutionContext {
  instanceId: string;
  workflowId: string;
  userId: string;
  variables: Record<string, any>;
  triggerData: any;
}

interface NodeExecutionResult {
  success: boolean;
  data?: any;
  error?: string;
  nextNodes?: string[];
}

export class WorkflowEngine extends EventEmitter {
  private nodeRegistry: NodeRegistry;
  private connectorManager: ConnectorManager;
  private executionQueue: Queue;
  private runningInstances: Map<string, ExecutionContext>;
  private logger: Logger;

  constructor() {
    super();
    this.nodeRegistry = new NodeRegistry();
    this.connectorManager = new ConnectorManager();
    this.executionQueue = new Queue('workflow execution', {
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      }
    });
    this.runningInstances = new Map();
    this.logger = new Logger('WorkflowEngine');

    this.setupQueueProcessors();
    this.registerBuiltinNodes();
  }

  // æ‰§è¡Œå·¥ä½œæµç¨‹
  async executeWorkflow(
    workflowId: string,
    triggerData: any,
    userId: string
  ): Promise<string> {
    try {
      this.logger.info(`å¼€å§‹æ‰§è¡Œå·¥ä½œæµç¨‹: ${workflowId}`);

      // 1. è·å–å·¥ä½œæµç¨‹å®šä¹‰
      const workflow = await WorkflowModel.findById(workflowId);
      if (!workflow) {
        throw new Error(`å·¥ä½œæµç¨‹ä¸å­˜åœ¨: ${workflowId}`);
      }

      if (workflow.status !== 'active') {
        throw new Error(`å·¥ä½œæµç¨‹æœªæ¿€æ´»: ${workflowId}`);
      }

      // 2. åˆ›å»ºæ‰§è¡Œå®ä¾‹
      const instance = new WorkflowInstanceModel({
        workflowId,
        userId,
        status: 'running',
        triggerData,
        executionLog: [],
        startTime: new Date()
      });
      await instance.save();

      // 3. åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
      const context: ExecutionContext = {
        instanceId: instance._id.toString(),
        workflowId,
        userId,
        variables: { ...triggerData },
        triggerData
      };

      this.runningInstances.set(context.instanceId, context);

      // 4. æŸ¥æ‰¾è§¦å‘èŠ‚ç‚¹å¹¶å¼€å§‹æ‰§è¡Œ
      const triggerNodes = workflow.nodes.filter(node => node.type === 'trigger');
      if (triggerNodes.length === 0) {
        throw new Error('å·¥ä½œæµç¨‹æ²¡æœ‰è§¦å‘èŠ‚ç‚¹');
      }

      // 5. å°†æ‰§è¡Œä»»åŠ¡åŠ å…¥é˜Ÿåˆ—
      await this.executionQueue.add('executeWorkflow', {
        context,
        workflow: workflow.toObject()
      });

      this.emit('workflow.started', {
        instanceId: context.instanceId,
        workflowId,
        userId
      });

      return context.instanceId;

    } catch (error) {
      this.logger.error('æ‰§è¡Œå·¥ä½œæµç¨‹å¤±è´¥:', error);
      throw error;
    }
  }

  // æ‰§è¡Œå•ä¸ªèŠ‚ç‚¹
  private async executeNode(
    node: any,
    context: ExecutionContext,
    workflow: any
  ): Promise<NodeExecutionResult> {
    const startTime = new Date();

    try {
      this.logger.info(`å¼€å§‹æ‰§è¡ŒèŠ‚ç‚¹: ${node.id} (${node.type})`);

      // 1. è®°å½•èŠ‚ç‚¹å¼€å§‹æ‰§è¡Œ
      await this.logNodeExecution(context.instanceId, node.id, 'running', {
        startTime,
        input: context.variables
      });

      this.emit('node.started', {
        instanceId: context.instanceId,
        nodeId: node.id,
        nodeType: node.type
      });

      // 2. è·å–èŠ‚ç‚¹æ‰§è¡Œå™¨
      const executor = this.nodeRegistry.getExecutor(node.type);
      if (!executor) {
        throw new Error(`æœªæ‰¾åˆ°èŠ‚ç‚¹ç±»å‹ ${node.type} çš„æ‰§è¡Œå™¨`);
      }

      // 3. å‡†å¤‡èŠ‚ç‚¹è¾“å…¥æ•°æ®
      const inputData = await this.prepareNodeInput(node, context, workflow);

      // 4. æ‰§è¡ŒèŠ‚ç‚¹
      const result = await executor.execute(node.data.config, inputData, context);

      // 5. å¤„ç†æ‰§è¡Œç»“æœ
      if (result.success) {
        // æ›´æ–°ä¸Šä¸‹æ–‡å˜é‡
        if (result.data) {
          context.variables = { ...context.variables, ...result.data };
        }

        // è®°å½•æˆåŠŸæ‰§è¡Œ
        await this.logNodeExecution(context.instanceId, node.id, 'completed', {
          endTime: new Date(),
          executionTime: Date.now() - startTime.getTime(),
          output: result.data
        });

        this.emit('node.completed', {
          instanceId: context.instanceId,
          nodeId: node.id,
          result: result.data
        });

        // 6. æŸ¥æ‰¾å¹¶æ‰§è¡Œä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        const nextNodes = this.findNextNodes(node, workflow, result);
        for (const nextNode of nextNodes) {
          // æ£€æŸ¥èŠ‚ç‚¹æ˜¯å¦å¯ä»¥æ‰§è¡Œï¼ˆæ‰€æœ‰å‰ç½®èŠ‚ç‚¹éƒ½å·²å®Œæˆï¼‰
          if (await this.canExecuteNode(nextNode, context, workflow)) {
            // å°†ä¸‹ä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥æ‰§è¡Œé˜Ÿåˆ—
            await this.executionQueue.add('executeNode', {
              node: nextNode,
              context,
              workflow
            });
          }
        }

        // 7. æ£€æŸ¥å·¥ä½œæµç¨‹æ˜¯å¦å®Œæˆ
        if (await this.isWorkflowCompleted(context, workflow)) {
          await this.completeWorkflow(context);
        }

        return { success: true, data: result.data, nextNodes: nextNodes.map(n => n.id) };

      } else {
        // è®°å½•æ‰§è¡Œå¤±è´¥
        await this.logNodeExecution(context.instanceId, node.id, 'failed', {
          endTime: new Date(),
          executionTime: Date.now() - startTime.getTime(),
          error: result.error
        });

        this.emit('node.failed', {
          instanceId: context.instanceId,
          nodeId: node.id,
          error: result.error
        });

        // æ ¹æ®é”™è¯¯å¤„ç†ç­–ç•¥å†³å®šæ˜¯å¦ç»§ç»­
        const shouldContinue = await this.handleNodeError(node, result.error, context);
        if (!shouldContinue) {
          await this.failWorkflow(context, result.error);
        }

        return { success: false, error: result.error };
      }

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);

      this.logger.error(`èŠ‚ç‚¹æ‰§è¡Œå¼‚å¸¸: ${node.id}`, error);

      // è®°å½•æ‰§è¡Œå¼‚å¸¸
      await this.logNodeExecution(context.instanceId, node.id, 'failed', {
        endTime: new Date(),
        executionTime: Date.now() - startTime.getTime(),
        error: errorMessage
      });

      this.emit('node.error', {
        instanceId: context.instanceId,
        nodeId: node.id,
        error: errorMessage
      });

      await this.failWorkflow(context, errorMessage);
      return { success: false, error: errorMessage };
    }
  }

  // å‡†å¤‡èŠ‚ç‚¹è¾“å…¥æ•°æ®
  private async prepareNodeInput(
    node: any,
    context: ExecutionContext,
    workflow: any
  ): Promise<any> {
    const inputData: any = {
      // åŸºç¡€ä¸Šä¸‹æ–‡ä¿¡æ¯
      _context: {
        instanceId: context.instanceId,
        workflowId: context.workflowId,
        userId: context.userId,
        nodeId: node.id
      },
      // å…¨å±€å˜é‡
      ...context.variables
    };

    // è·å–å‰ç½®èŠ‚ç‚¹çš„è¾“å‡ºæ•°æ®
    const incomingEdges = workflow.edges.filter(edge => edge.target === node.id);
    for (const edge of incomingEdges) {
      const sourceNodeOutput = await this.getNodeOutput(context.instanceId, edge.source);
      if (sourceNodeOutput) {
        // æ ¹æ®è¿æ¥ç‚¹æ˜ å°„æ•°æ®
        const mappedData = this.mapNodeData(sourceNodeOutput, edge);
        Object.assign(inputData, mappedData);
      }
    }

    return inputData;
  }

  // æŸ¥æ‰¾ä¸‹ä¸€ä¸ªè¦æ‰§è¡Œçš„èŠ‚ç‚¹
  private findNextNodes(currentNode: any, workflow: any, result: NodeExecutionResult): any[] {
    const outgoingEdges = workflow.edges.filter(edge => edge.source === currentNode.id);
    const nextNodes: any[] = [];

    for (const edge of outgoingEdges) {
      const targetNode = workflow.nodes.find(node => node.id === edge.target);
      if (targetNode) {
        // å¯¹äºæ¡ä»¶èŠ‚ç‚¹ï¼Œæ ¹æ®æ‰§è¡Œç»“æœé€‰æ‹©åˆ†æ”¯
        if (currentNode.type === 'condition') {
          const conditionResult = result.data?.result;
          if (
            (edge.sourceHandle === 'true' && conditionResult) ||
            (edge.sourceHandle === 'false' && !conditionResult) ||
            (!edge.sourceHandle) // é»˜è®¤è¾“å‡º
          ) {
            nextNodes.push(targetNode);
          }
        } else {
          nextNodes.push(targetNode);
        }
      }
    }

    return nextNodes;
  }

  // è®¾ç½®é˜Ÿåˆ—å¤„ç†å™¨
  private setupQueueProcessors(): void {
    // å·¥ä½œæµç¨‹æ‰§è¡Œå¤„ç†å™¨
    this.executionQueue.process('executeWorkflow', async (job) => {
      const { context, workflow } = job.data;

      // æ‰§è¡Œè§¦å‘èŠ‚ç‚¹
      const triggerNodes = workflow.nodes.filter(node => node.type === 'trigger');
      for (const triggerNode of triggerNodes) {
        await this.executeNode(triggerNode, context, workflow);
      }
    });

    // èŠ‚ç‚¹æ‰§è¡Œå¤„ç†å™¨
    this.executionQueue.process('executeNode', async (job) => {
      const { node, context, workflow } = job.data;
      await this.executeNode(node, context, workflow);
    });

    // é”™è¯¯å¤„ç†
    this.executionQueue.on('failed', (job, err) => {
      this.logger.error(`é˜Ÿåˆ—ä»»åŠ¡å¤±è´¥: ${job.id}`, err);
    });
  }

  // æ³¨å†Œå†…ç½®èŠ‚ç‚¹ç±»å‹
  private registerBuiltinNodes(): void {
    this.nodeRegistry.registerBuiltinNodes();
  }

  // å…¶ä»–è¾…åŠ©æ–¹æ³•...
  private async logNodeExecution(instanceId: string, nodeId: string, status: string, data: any) {
    await WorkflowInstanceModel.findByIdAndUpdate(instanceId, {
      $push: {
        executionLog: {
          nodeId,
          status,
          timestamp: new Date(),
          ...data
        }
      }
    });
  }

  private async completeWorkflow(context: ExecutionContext) {
    await WorkflowInstanceModel.findByIdAndUpdate(context.instanceId, {
      status: 'completed',
      endTime: new Date()
    });

    this.runningInstances.delete(context.instanceId);
    this.emit('workflow.completed', { instanceId: context.instanceId });
    this.logger.info(`å·¥ä½œæµç¨‹æ‰§è¡Œå®Œæˆ: ${context.instanceId}`);
  }

  private async failWorkflow(context: ExecutionContext, error: string) {
    await WorkflowInstanceModel.findByIdAndUpdate(context.instanceId, {
      status: 'failed',
      error,
      endTime: new Date()
    });

    this.runningInstances.delete(context.instanceId);
    this.emit('workflow.failed', { instanceId: context.instanceId, error });
    this.logger.error(`å·¥ä½œæµç¨‹æ‰§è¡Œå¤±è´¥: ${context.instanceId}`, error);
  }

  // åœæ­¢å·¥ä½œæµç¨‹æ‰§è¡Œ
  async stopWorkflow(instanceId: string): Promise<void> {
    const context = this.runningInstances.get(instanceId);
    if (context) {
      await WorkflowInstanceModel.findByIdAndUpdate(instanceId, {
        status: 'cancelled',
        endTime: new Date()
      });

      this.runningInstances.delete(instanceId);
      this.emit('workflow.cancelled', { instanceId });
      this.logger.info(`å·¥ä½œæµç¨‹æ‰§è¡Œå·²åœæ­¢: ${instanceId}`);
    }
  }
}
```

## ï¼ˆä¸‰ï¼‰èŠ‚ç‚¹æ³¨å†Œè¡¨å’Œæ‰§è¡Œå™¨å®ç°

**èŠ‚ç‚¹æ³¨å†Œè¡¨**

```typescript
// server/src/services/NodeRegistry.ts
import { ExecutionContext } from './WorkflowEngine';

export interface NodeExecutor {
  execute(config: any, inputData: any, context: ExecutionContext): Promise<{
    success: boolean;
    data?: any;
    error?: string;
  }>;
}

export class NodeRegistry {
  private executors: Map<string, NodeExecutor> = new Map();

  // æ³¨å†ŒèŠ‚ç‚¹æ‰§è¡Œå™¨
  register(nodeType: string, executor: NodeExecutor) {
    this.executors.set(nodeType, executor);
    console.log(`âœ… èŠ‚ç‚¹ç±»å‹å·²æ³¨å†Œ: ${nodeType}`);
  }

  // è·å–èŠ‚ç‚¹æ‰§è¡Œå™¨
  getExecutor(nodeType: string): NodeExecutor | undefined {
    return this.executors.get(nodeType);
  }

  // æ³¨å†Œå†…ç½®èŠ‚ç‚¹
  registerBuiltinNodes() {
    // HTTPè¯·æ±‚èŠ‚ç‚¹
    this.register('http_request', new HttpRequestExecutor());

    // é‚®ä»¶å‘é€èŠ‚ç‚¹
    this.register('email', new EmailExecutor());

    // æ¡ä»¶åˆ¤æ–­èŠ‚ç‚¹
    this.register('condition', new ConditionExecutor());

    // æ•°æ®è½¬æ¢èŠ‚ç‚¹
    this.register('transform', new TransformExecutor());

    // Slackæ¶ˆæ¯èŠ‚ç‚¹
    this.register('slack_message', new SlackMessageExecutor());

    // GitHubæ“ä½œèŠ‚ç‚¹
    this.register('github_action', new GitHubActionExecutor());
  }
}

// HTTPè¯·æ±‚æ‰§è¡Œå™¨
class HttpRequestExecutor implements NodeExecutor {
  async execute(config: any, inputData: any, context: ExecutionContext) {
    try {
      const axios = require('axios');

      const requestConfig = {
        url: this.replaceVariables(config.url || inputData.url, inputData),
        method: config.method || 'GET',
        headers: config.headers || {},
        data: config.body || inputData.body,
        timeout: config.timeout || 30000
      };

      // å¤„ç†è®¤è¯
      if (config.auth) {
        if (config.auth.type === 'bearer') {
          requestConfig.headers.Authorization = `Bearer ${config.auth.token}`;
        } else if (config.auth.type === 'basic') {
          requestConfig.auth = {
            username: config.auth.username,
            password: config.auth.password
          };
        }
      }

      const response = await axios(requestConfig);

      return {
        success: true,
        data: {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers,
          body: response.data,
          url: response.config.url
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `HTTPè¯·æ±‚å¤±è´¥: ${error.response?.data?.message || error.message}`
      };
    }
  }

  private replaceVariables(template: string, variables: any): string {
    if (!template) return '';

    return template.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
      const keys = key.trim().split('.');
      let value = variables;

      for (const k of keys) {
        if (value && typeof value === 'object' && k in value) {
          value = value[k];
        } else {
          return match; // ä¿æŒåŸæ ·å¦‚æœæ‰¾ä¸åˆ°å˜é‡
        }
      }

      return String(value);
    });
  }
}

// æ¡ä»¶åˆ¤æ–­æ‰§è¡Œå™¨
class ConditionExecutor implements NodeExecutor {
  async execute(config: any, inputData: any, context: ExecutionContext) {
    try {
      const { field, operator, value } = config;
      const actualValue = this.getNestedValue(inputData, field);

      let result = false;

      switch (operator) {
        case 'equals':
          result = actualValue === value;
          break;
        case 'not_equals':
          result = actualValue !== value;
          break;
        case 'greater_than':
          result = Number(actualValue) > Number(value);
          break;
        case 'less_than':
          result = Number(actualValue) < Number(value);
          break;
        case 'greater_equal':
          result = Number(actualValue) >= Number(value);
          break;
        case 'less_equal':
          result = Number(actualValue) <= Number(value);
          break;
        case 'contains':
          result = String(actualValue).includes(String(value));
          break;
        case 'not_contains':
          result = !String(actualValue).includes(String(value));
          break;
        case 'starts_with':
          result = String(actualValue).startsWith(String(value));
          break;
        case 'ends_with':
          result = String(actualValue).endsWith(String(value));
          break;
        case 'regex':
          result = new RegExp(value).test(String(actualValue));
          break;
        case 'is_empty':
          result = !actualValue || actualValue === '' || actualValue === null || actualValue === undefined;
          break;
        case 'is_not_empty':
          result = !!actualValue && actualValue !== '' && actualValue !== null && actualValue !== undefined;
          break;
        default:
          throw new Error(`ä¸æ”¯æŒçš„æ“ä½œç¬¦: ${operator}`);
      }

      return {
        success: true,
        data: {
          result,
          actualValue,
          expectedValue: value,
          operator,
          field
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `æ¡ä»¶åˆ¤æ–­å¤±è´¥: ${error.message}`
      };
    }
  }

  private getNestedValue(obj: any, path: string): any {
    return path.split('.').reduce((current, key) => {
      return current && current[key] !== undefined ? current[key] : undefined;
    }, obj);
  }
}

// Slackæ¶ˆæ¯æ‰§è¡Œå™¨
class SlackMessageExecutor implements NodeExecutor {
  async execute(config: any, inputData: any, context: ExecutionContext) {
    try {
      const { WebClient } = require('@slack/web-api');

      // ä»è¿æ¥å™¨ç®¡ç†å™¨è·å–Slackä»¤ç‰Œ
      const connectorManager = new (require('./ConnectorManager').ConnectorManager)();
      const slackConnector = await connectorManager.getConnector(
        context.userId,
        'slack',
        config.connectorId
      );

      if (!slackConnector) {
        throw new Error('Slackè¿æ¥å™¨æœªé…ç½®æˆ–å·²å¤±æ•ˆ');
      }

      const slack = new WebClient(slackConnector.config.accessToken);

      const message = this.replaceVariables(config.message, inputData);
      const channel = config.channel || inputData.channel;

      if (!channel) {
        throw new Error('æœªæŒ‡å®šSlacké¢‘é“');
      }

      const messageOptions: any = {
        channel,
        text: message
      };

      // æ”¯æŒå¯Œæ–‡æœ¬å—
      if (config.blocks && Array.isArray(config.blocks)) {
        messageOptions.blocks = config.blocks.map(block =>
          this.processSlackBlock(block, inputData)
        );
      }

      // æ”¯æŒé™„ä»¶
      if (config.attachments && Array.isArray(config.attachments)) {
        messageOptions.attachments = config.attachments;
      }

      // æ”¯æŒçº¿ç¨‹å›å¤
      if (config.threadTs || inputData.threadTs) {
        messageOptions.thread_ts = config.threadTs || inputData.threadTs;
      }

      const result = await slack.chat.postMessage(messageOptions);

      return {
        success: true,
        data: {
          messageId: result.ts,
          channel: result.channel,
          permalink: await this.getPermalink(slack, result.channel, result.ts)
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `å‘é€Slackæ¶ˆæ¯å¤±è´¥: ${error.message}`
      };
    }
  }

  private replaceVariables(template: string, variables: any): string {
    if (!template) return '';

    return template.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
      const keys = key.trim().split('.');
      let value = variables;

      for (const k of keys) {
        if (value && typeof value === 'object' && k in value) {
          value = value[k];
        } else {
          return match;
        }
      }

      return String(value);
    });
  }

  private processSlackBlock(block: any, variables: any): any {
    // é€’å½’å¤„ç†Slackå—ä¸­çš„å˜é‡æ›¿æ¢
    if (typeof block === 'string') {
      return this.replaceVariables(block, variables);
    } else if (Array.isArray(block)) {
      return block.map(item => this.processSlackBlock(item, variables));
    } else if (typeof block === 'object' && block !== null) {
      const processedBlock = {};
      for (const [key, value] of Object.entries(block)) {
        processedBlock[key] = this.processSlackBlock(value, variables);
      }
      return processedBlock;
    }
    return block;
  }

  private async getPermalink(slack: any, channel: string, ts: string): Promise<string> {
    try {
      const result = await slack.chat.getPermalink({ channel, message_ts: ts });
      return result.permalink;
    } catch (error) {
      return '';
    }
  }
}

// é‚®ä»¶å‘é€æ‰§è¡Œå™¨
class EmailExecutor implements NodeExecutor {
  async execute(config: any, inputData: any, context: ExecutionContext) {
    try {
      const nodemailer = require('nodemailer');

      // ä»è¿æ¥å™¨ç®¡ç†å™¨è·å–é‚®ä»¶é…ç½®
      const connectorManager = new (require('./ConnectorManager').ConnectorManager)();
      const emailConnector = await connectorManager.getConnector(
        context.userId,
        'email',
        config.connectorId
      );

      if (!emailConnector) {
        throw new Error('é‚®ä»¶è¿æ¥å™¨æœªé…ç½®æˆ–å·²å¤±æ•ˆ');
      }

      const transporter = nodemailer.createTransporter({
        host: emailConnector.config.host,
        port: emailConnector.config.port,
        secure: emailConnector.config.secure,
        auth: {
          user: emailConnector.config.username,
          pass: emailConnector.config.password
        }
      });

      const mailOptions = {
        from: config.from || emailConnector.config.from,
        to: this.replaceVariables(config.to, inputData),
        cc: config.cc ? this.replaceVariables(config.cc, inputData) : undefined,
        bcc: config.bcc ? this.replaceVariables(config.bcc, inputData) : undefined,
        subject: this.replaceVariables(config.subject, inputData),
        text: config.textContent ? this.replaceVariables(config.textContent, inputData) : undefined,
        html: config.htmlContent ? this.replaceVariables(config.htmlContent, inputData) : undefined,
        attachments: config.attachments || undefined
      };

      const result = await transporter.sendMail(mailOptions);

      return {
        success: true,
        data: {
          messageId: result.messageId,
          accepted: result.accepted,
          rejected: result.rejected
        }
      };
    } catch (error) {
      return {
        success: false,
        error: `å‘é€é‚®ä»¶å¤±è´¥: ${error.message}`
      };
    }
  }

  private replaceVariables(template: string, variables: any): string {
    if (!template) return '';

    return template.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
      const keys = key.trim().split('.');
      let value = variables;

      for (const k of keys) {
        if (value && typeof value === 'object' && k in value) {
          value = value[k];
        } else {
          return match;
        }
      }

      return String(value);
    });
  }
}

// æ•°æ®è½¬æ¢æ‰§è¡Œå™¨
class TransformExecutor implements NodeExecutor {
  async execute(config: any, inputData: any, context: ExecutionContext) {
    try {
      const { script, language = 'javascript' } = config;

      if (language === 'javascript') {
        return this.executeJavaScript(script, inputData, context);
      } else {
        throw new Error(`ä¸æ”¯æŒçš„è„šæœ¬è¯­è¨€: ${language}`);
      }
    } catch (error) {
      return {
        success: false,
        error: `æ•°æ®è½¬æ¢å¤±è´¥: ${error.message}`
      };
    }
  }

  private async executeJavaScript(script: string, inputData: any, context: ExecutionContext) {
    try {
      // åˆ›å»ºå®‰å…¨çš„æ‰§è¡Œç¯å¢ƒ
      const vm = require('vm');
      const sandbox = {
        input: inputData,
        output: {},
        console: {
          log: (...args) => console.log(`[Transform ${context.instanceId}]`, ...args)
        },
        // æä¾›ä¸€äº›å®ç”¨å‡½æ•°
        JSON,
        Math,
        Date,
        String,
        Number,
        Array,
        Object
      };

      // æ‰§è¡Œè„šæœ¬
      const vmContext = vm.createContext(sandbox);
      vm.runInContext(script, vmContext, {
        timeout: 30000, // 30ç§’è¶…æ—¶
        displayErrors: true
      });

      return {
        success: true,
        data: sandbox.output
      };
    } catch (error) {
      return {
        success: false,
        error: `JavaScriptæ‰§è¡Œå¤±è´¥: ${error.message}`
      };
    }
  }
}

// GitHubæ“ä½œæ‰§è¡Œå™¨
class GitHubActionExecutor implements NodeExecutor {
  async execute(config: any, inputData: any, context: ExecutionContext) {
    try {
      const { Octokit } = require('@octokit/rest');

      // ä»è¿æ¥å™¨ç®¡ç†å™¨è·å–GitHubä»¤ç‰Œ
      const connectorManager = new (require('./ConnectorManager').ConnectorManager)();
      const githubConnector = await connectorManager.getConnector(
        context.userId,
        'github',
        config.connectorId
      );

      if (!githubConnector) {
        throw new Error('GitHubè¿æ¥å™¨æœªé…ç½®æˆ–å·²å¤±æ•ˆ');
      }

      const octokit = new Octokit({
        auth: githubConnector.config.accessToken
      });

      const { action, owner, repo } = config;

      switch (action) {
        case 'create_issue':
          return await this.createIssue(octokit, config, inputData);
        case 'create_pr':
          return await this.createPullRequest(octokit, config, inputData);
        case 'add_comment':
          return await this.addComment(octokit, config, inputData);
        case 'create_release':
          return await this.createRelease(octokit, config, inputData);
        default:
          throw new Error(`ä¸æ”¯æŒçš„GitHubæ“ä½œ: ${action}`);
      }
    } catch (error) {
      return {
        success: false,
        error: `GitHubæ“ä½œå¤±è´¥: ${error.message}`
      };
    }
  }

  private async createIssue(octokit: any, config: any, inputData: any) {
    const result = await octokit.issues.create({
      owner: config.owner,
      repo: config.repo,
      title: this.replaceVariables(config.title, inputData),
      body: this.replaceVariables(config.body, inputData),
      labels: config.labels || [],
      assignees: config.assignees || []
    });

    return {
      success: true,
      data: {
        issueNumber: result.data.number,
        issueUrl: result.data.html_url,
        issueId: result.data.id
      }
    };
  }

  private async createPullRequest(octokit: any, config: any, inputData: any) {
    const result = await octokit.pulls.create({
      owner: config.owner,
      repo: config.repo,
      title: this.replaceVariables(config.title, inputData),
      body: this.replaceVariables(config.body, inputData),
      head: config.head,
      base: config.base || 'main'
    });

    return {
      success: true,
      data: {
        prNumber: result.data.number,
        prUrl: result.data.html_url,
        prId: result.data.id
      }
    };
  }

  private async addComment(octokit: any, config: any, inputData: any) {
    const result = await octokit.issues.createComment({
      owner: config.owner,
      repo: config.repo,
      issue_number: config.issueNumber || inputData.issueNumber,
      body: this.replaceVariables(config.body, inputData)
    });

    return {
      success: true,
      data: {
        commentId: result.data.id,
        commentUrl: result.data.html_url
      }
    };
  }

  private async createRelease(octokit: any, config: any, inputData: any) {
    const result = await octokit.repos.createRelease({
      owner: config.owner,
      repo: config.repo,
      tag_name: this.replaceVariables(config.tagName, inputData),
      name: this.replaceVariables(config.name, inputData),
      body: this.replaceVariables(config.body, inputData),
      draft: config.draft || false,
      prerelease: config.prerelease || false
    });

    return {
      success: true,
      data: {
        releaseId: result.data.id,
        releaseUrl: result.data.html_url,
        tagName: result.data.tag_name
      }
    };
  }

  private replaceVariables(template: string, variables: any): string {
    if (!template) return '';

    return template.replace(/\{\{([^}]+)\}\}/g, (match, key) => {
      const keys = key.trim().split('.');
      let value = variables;

      for (const k of keys) {
        if (value && typeof value === 'object' && k in value) {
          value = value[k];
        } else {
          return match;
        }
      }

      return String(value);
    });
  }
}
```

## ï¼ˆå››ï¼‰è¿æ¥å™¨ç®¡ç†ç³»ç»Ÿ

**è¿æ¥å™¨ç®¡ç†å™¨å®ç°**

```typescript
// server/src/services/ConnectorManager.ts
import { ConnectorModel } from '../models';
import { encrypt, decrypt } from '../utils/crypto';
import { Logger } from '../utils/logger';

export interface Connector {
  id: string;
  type: string;
  name: string;
  config: any;
  isActive: boolean;
}

export class ConnectorManager {
  private logger: Logger;

  constructor() {
    this.logger = new Logger('ConnectorManager');
  }

  // åˆ›å»ºè¿æ¥å™¨
  async createConnector(
    userId: string,
    type: string,
    name: string,
    config: any
  ): Promise<string> {
    try {
      this.logger.info(`åˆ›å»ºè¿æ¥å™¨: ${type} - ${name}`);

      // éªŒè¯é…ç½®
      const validation = await this.validateConfig(type, config);
      if (!validation.isValid) {
        throw new Error(`é…ç½®éªŒè¯å¤±è´¥: ${validation.errors.join(', ')}`);
      }

      // åŠ å¯†æ•æ„Ÿé…ç½®ä¿¡æ¯
      const encryptedConfig = this.encryptConfig(config);

      const connector = new ConnectorModel({
        userId,
        type,
        name,
        config: encryptedConfig,
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      });

      await connector.save();

      // æµ‹è¯•è¿æ¥
      const isValid = await this.testConnection(type, config);
      if (!isValid) {
        await connector.deleteOne();
        throw new Error('è¿æ¥æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®');
      }

      this.logger.info(`è¿æ¥å™¨åˆ›å»ºæˆåŠŸ: ${connector._id}`);
      return connector._id.toString();
    } catch (error) {
      this.logger.error('åˆ›å»ºè¿æ¥å™¨å¤±è´¥:', error);
      throw error;
    }
  }

  // è·å–è¿æ¥å™¨
  async getConnector(
    userId: string,
    type: string,
    connectorId?: string
  ): Promise<Connector | null> {
    try {
      const query: any = { userId, type, isActive: true };
      if (connectorId) {
        query._id = connectorId;
      }

      const connector = await ConnectorModel.findOne(query);
      if (!connector) {
        return null;
      }

      // è§£å¯†é…ç½®ä¿¡æ¯
      const decryptedConfig = this.decryptConfig(connector.config);

      return {
        id: connector._id.toString(),
        type: connector.type,
        name: connector.name,
        config: decryptedConfig,
        isActive: connector.isActive
      };
    } catch (error) {
      this.logger.error('è·å–è¿æ¥å™¨å¤±è´¥:', error);
      return null;
    }
  }

  // æ›´æ–°è¿æ¥å™¨
  async updateConnector(
    connectorId: string,
    userId: string,
    updates: Partial<{ name: string; config: any }>
  ): Promise<void> {
    try {
      const updateData: any = { updatedAt: new Date() };

      if (updates.name) {
        updateData.name = updates.name;
      }

      if (updates.config) {
        // éªŒè¯æ–°é…ç½®
        const connector = await ConnectorModel.findOne({ _id: connectorId, userId });
        if (!connector) {
          throw new Error('è¿æ¥å™¨ä¸å­˜åœ¨');
        }

        const validation = await this.validateConfig(connector.type, updates.config);
        if (!validation.isValid) {
          throw new Error(`é…ç½®éªŒè¯å¤±è´¥: ${validation.errors.join(', ')}`);
        }

        // æµ‹è¯•æ–°é…ç½®
        const isValid = await this.testConnection(connector.type, updates.config);
        if (!isValid) {
          throw new Error('è¿æ¥æµ‹è¯•å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®');
        }

        updateData.config = this.encryptConfig(updates.config);
      }

      await ConnectorModel.findOneAndUpdate(
        { _id: connectorId, userId },
        updateData
      );

      this.logger.info(`è¿æ¥å™¨æ›´æ–°æˆåŠŸ: ${connectorId}`);
    } catch (error) {
      this.logger.error('æ›´æ–°è¿æ¥å™¨å¤±è´¥:', error);
      throw error;
    }
  }

  // åˆ é™¤è¿æ¥å™¨
  async deleteConnector(connectorId: string, userId: string): Promise<void> {
    try {
      await ConnectorModel.findOneAndUpdate(
        { _id: connectorId, userId },
        { isActive: false, updatedAt: new Date() }
      );

      this.logger.info(`è¿æ¥å™¨åˆ é™¤æˆåŠŸ: ${connectorId}`);
    } catch (error) {
      this.logger.error('åˆ é™¤è¿æ¥å™¨å¤±è´¥:', error);
      throw error;
    }
  }

  // æµ‹è¯•è¿æ¥
  async testConnection(type: string, config: any): Promise<boolean> {
    try {
      switch (type) {
        case 'slack':
          return await this.testSlackConnection(config);
        case 'github':
          return await this.testGitHubConnection(config);
        case 'email':
          return await this.testEmailConnection(config);
        case 'webhook':
          return await this.testWebhookConnection(config);
        default:
          this.logger.warn(`æœªçŸ¥è¿æ¥å™¨ç±»å‹: ${type}`);
          return true; // é»˜è®¤é€šè¿‡
      }
    } catch (error) {
      this.logger.error(`æµ‹è¯•${type}è¿æ¥å¤±è´¥:`, error);
      return false;
    }
  }

  // éªŒè¯é…ç½®
  private async validateConfig(type: string, config: any): Promise<{ isValid: boolean; errors: string[] }> {
    const errors: string[] = [];

    switch (type) {
      case 'slack':
        if (!config.accessToken) errors.push('ç¼ºå°‘Slackè®¿é—®ä»¤ç‰Œ');
        break;
      case 'github':
        if (!config.accessToken) errors.push('ç¼ºå°‘GitHubè®¿é—®ä»¤ç‰Œ');
        break;
      case 'email':
        if (!config.host) errors.push('ç¼ºå°‘SMTPä¸»æœº');
        if (!config.port) errors.push('ç¼ºå°‘SMTPç«¯å£');
        if (!config.username) errors.push('ç¼ºå°‘ç”¨æˆ·å');
        if (!config.password) errors.push('ç¼ºå°‘å¯†ç ');
        break;
      case 'webhook':
        if (!config.url) errors.push('ç¼ºå°‘Webhook URL');
        break;
    }

    return { isValid: errors.length === 0, errors };
  }

  private async testSlackConnection(config: any): Promise<boolean> {
    const { WebClient } = require('@slack/web-api');
    const slack = new WebClient(config.accessToken);

    try {
      const result = await slack.auth.test();
      return result.ok;
    } catch (error) {
      return false;
    }
  }

  private async testGitHubConnection(config: any): Promise<boolean> {
    const { Octokit } = require('@octokit/rest');
    const octokit = new Octokit({ auth: config.accessToken });

    try {
      const result = await octokit.users.getAuthenticated();
      return !!result.data;
    } catch (error) {
      return false;
    }
  }

  private async testEmailConnection(config: any): Promise<boolean> {
    const nodemailer = require('nodemailer');

    try {
      const transporter = nodemailer.createTransporter({
        host: config.host,
        port: config.port,
        secure: config.secure,
        auth: {
          user: config.username,
          pass: config.password
        }
      });

      await transporter.verify();
      return true;
    } catch (error) {
      return false;
    }
  }

  private async testWebhookConnection(config: any): Promise<boolean> {
    const axios = require('axios');

    try {
      const response = await axios.head(config.url, { timeout: 5000 });
      return response.status < 400;
    } catch (error) {
      return false;
    }
  }

  private encryptConfig(config: any): any {
    // åŠ å¯†æ•æ„Ÿå­—æ®µ
    const sensitiveFields = ['accessToken', 'refreshToken', 'apiKey', 'password', 'secret'];
    const encrypted = { ...config };

    for (const field of sensitiveFields) {
      if (encrypted[field]) {
        encrypted[field] = encrypt(encrypted[field]);
      }
    }

    return encrypted;
  }

  private decryptConfig(config: any): any {
    // è§£å¯†æ•æ„Ÿå­—æ®µ
    const sensitiveFields = ['accessToken', 'refreshToken', 'apiKey', 'password', 'secret'];
    const decrypted = { ...config };

    for (const field of sensitiveFields) {
      if (decrypted[field]) {
        decrypted[field] = decrypt(decrypted[field]);
      }
    }

    return decrypted;
  }
}
```

# å››ã€éƒ¨ç½²ä¸ä¼˜åŒ–

## ï¼ˆä¸€ï¼‰Dockerå®¹å™¨åŒ–éƒ¨ç½²

**å‰ç«¯Dockerfile**

```dockerfile
# frontend/Dockerfile
FROM node:18-alpine AS builder

WORKDIR /app

# å¤åˆ¶packageæ–‡ä»¶
COPY package*.json ./
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç å¹¶æ„å»º
COPY . .
RUN npm run build

# ç”Ÿäº§ç¯å¢ƒ
FROM nginx:alpine

# å¤åˆ¶æ„å»ºäº§ç‰©
COPY --from=builder /app/build /usr/share/nginx/html

# å¤åˆ¶nginxé…ç½®
COPY nginx.conf /etc/nginx/nginx.conf

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

**åç«¯Dockerfile**

```dockerfile
# backend/Dockerfile
FROM node:18-alpine

WORKDIR /app

# å®‰è£…ä¾èµ–
COPY package*.json ./
RUN npm ci --only=production

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºTypeScript
RUN npm run build

# åˆ›å»ºérootç”¨æˆ·
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

USER nodejs

EXPOSE 3001

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:3001/health || exit 1

CMD ["node", "dist/index.js"]
```

**Docker Composeé…ç½®**

```yaml
# docker-compose.yml
version: '3.8'

services:
  # å‰ç«¯æœåŠ¡
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:80"
    environment:
      - REACT_APP_API_BASE_URL=http://localhost:3001/api
    depends_on:
      - backend
    networks:
      - workflow-network

  # åç«¯æœåŠ¡
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    environment:
      - NODE_ENV=production
      - MONGODB_URI=mongodb://mongodb:27017/workflow
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=${JWT_SECRET}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
    depends_on:
      - mongodb
      - redis
    networks:
      - workflow-network
    volumes:
      - ./logs:/app/logs

  # MongoDBæ•°æ®åº“
  mongodb:
    image: mongo:6.0
    ports:
      - "27017:27017"
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_USERNAME}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_PASSWORD}
    volumes:
      - mongodb_data:/data/db
      - ./mongodb/init:/docker-entrypoint-initdb.d
    networks:
      - workflow-network

  # Redisç¼“å­˜
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis_data:/data
    networks:
      - workflow-network

  # Nginxè´Ÿè½½å‡è¡¡å™¨
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend
    networks:
      - workflow-network

volumes:
  mongodb_data:
  redis_data:

networks:
  workflow-network:
    driver: bridge
```

## ï¼ˆäºŒï¼‰æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**1. æ•°æ®åº“ä¼˜åŒ–**

```javascript
// MongoDBç´¢å¼•ä¼˜åŒ–
db.workflows.createIndex({ "userId": 1, "status": 1 });
db.workflows.createIndex({ "createdAt": -1 });
db.workflowInstances.createIndex({ "workflowId": 1, "status": 1 });
db.workflowInstances.createIndex({ "userId": 1, "startTime": -1 });
db.connectors.createIndex({ "userId": 1, "type": 1, "isActive": 1 });

// å¤åˆç´¢å¼•ç”¨äºå¤æ‚æŸ¥è¯¢
db.workflowInstances.createIndex({
  "userId": 1,
  "status": 1,
  "startTime": -1
});
```

**2. ç¼“å­˜ç­–ç•¥å®ç°**

```typescript
// server/src/services/CacheManager.ts
import Redis from 'ioredis';
import { Logger } from '../utils/logger';

export class CacheManager {
  private redis: Redis;
  private logger: Logger;

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
      password: process.env.REDIS_PASSWORD,
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3
    });

    this.logger = new Logger('CacheManager');
  }

  // ç¼“å­˜å·¥ä½œæµç¨‹å®šä¹‰
  async cacheWorkflow(workflowId: string, workflow: any, ttl: number = 3600): Promise<void> {
    try {
      const key = `workflow:${workflowId}`;
      await this.redis.setex(key, ttl, JSON.stringify(workflow));
      this.logger.debug(`å·¥ä½œæµç¨‹å·²ç¼“å­˜: ${workflowId}`);
    } catch (error) {
      this.logger.error('ç¼“å­˜å·¥ä½œæµç¨‹å¤±è´¥:', error);
    }
  }

  // è·å–ç¼“å­˜çš„å·¥ä½œæµç¨‹
  async getCachedWorkflow(workflowId: string): Promise<any | null> {
    try {
      const key = `workflow:${workflowId}`;
      const cached = await this.redis.get(key);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      this.logger.error('è·å–ç¼“å­˜å·¥ä½œæµç¨‹å¤±è´¥:', error);
      return null;
    }
  }

  // ç¼“å­˜æ‰§è¡ŒçŠ¶æ€
  async cacheExecutionStatus(instanceId: string, status: any, ttl: number = 1800): Promise<void> {
    try {
      const key = `execution:${instanceId}`;
      await this.redis.setex(key, ttl, JSON.stringify(status));
    } catch (error) {
      this.logger.error('ç¼“å­˜æ‰§è¡ŒçŠ¶æ€å¤±è´¥:', error);
    }
  }

  // ç¼“å­˜è¿æ¥å™¨é…ç½®
  async cacheConnector(userId: string, connectorId: string, config: any, ttl: number = 7200): Promise<void> {
    try {
      const key = `connector:${userId}:${connectorId}`;
      await this.redis.setex(key, ttl, JSON.stringify(config));
    } catch (error) {
      this.logger.error('ç¼“å­˜è¿æ¥å™¨å¤±è´¥:', error);
    }
  }

  // æ¸…é™¤ç¼“å­˜
  async clearCache(pattern: string): Promise<void> {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length > 0) {
        await this.redis.del(...keys);
        this.logger.info(`æ¸…é™¤ç¼“å­˜: ${keys.length} ä¸ªé”®`);
      }
    } catch (error) {
      this.logger.error('æ¸…é™¤ç¼“å­˜å¤±è´¥:', error);
    }
  }
}
```

**3. ä»»åŠ¡é˜Ÿåˆ—ä¼˜åŒ–**

```typescript
// server/src/services/QueueManager.ts
import Bull from 'bull';
import { Logger } from '../utils/logger';

export class QueueManager {
  private queues: Map<string, Bull.Queue> = new Map();
  private logger: Logger;

  constructor() {
    this.logger = new Logger('QueueManager');
    this.initializeQueues();
  }

  private initializeQueues(): void {
    // é«˜ä¼˜å…ˆçº§é˜Ÿåˆ— - ç”¨æˆ·è§¦å‘çš„å·¥ä½œæµç¨‹
    const highPriorityQueue = new Bull('high-priority', {
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
      defaultJobOptions: {
        removeOnComplete: 100,
        removeOnFail: 50,
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000,
        },
      },
    });

    // æ™®é€šä¼˜å…ˆçº§é˜Ÿåˆ— - å®šæ—¶è§¦å‘çš„å·¥ä½œæµç¨‹
    const normalPriorityQueue = new Bull('normal-priority', {
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
      defaultJobOptions: {
        removeOnComplete: 50,
        removeOnFail: 25,
        attempts: 2,
        backoff: {
          type: 'fixed',
          delay: 5000,
        },
      },
    });

    // ä½ä¼˜å…ˆçº§é˜Ÿåˆ— - æ‰¹é‡å¤„ç†ä»»åŠ¡
    const lowPriorityQueue = new Bull('low-priority', {
      redis: {
        host: process.env.REDIS_HOST || 'localhost',
        port: parseInt(process.env.REDIS_PORT || '6379'),
      },
      defaultJobOptions: {
        removeOnComplete: 25,
        removeOnFail: 10,
        attempts: 1,
      },
    });

    this.queues.set('high', highPriorityQueue);
    this.queues.set('normal', normalPriorityQueue);
    this.queues.set('low', lowPriorityQueue);

    // è®¾ç½®å¹¶å‘å¤„ç†æ•°
    highPriorityQueue.process(10);
    normalPriorityQueue.process(5);
    lowPriorityQueue.process(2);

    this.setupQueueEvents();
  }

  private setupQueueEvents(): void {
    this.queues.forEach((queue, name) => {
      queue.on('completed', (job) => {
        this.logger.info(`é˜Ÿåˆ— ${name} ä»»åŠ¡å®Œæˆ: ${job.id}`);
      });

      queue.on('failed', (job, err) => {
        this.logger.error(`é˜Ÿåˆ— ${name} ä»»åŠ¡å¤±è´¥: ${job.id}`, err);
      });

      queue.on('stalled', (job) => {
        this.logger.warn(`é˜Ÿåˆ— ${name} ä»»åŠ¡åœæ»: ${job.id}`);
      });
    });
  }

  // æ·»åŠ ä»»åŠ¡åˆ°æŒ‡å®šä¼˜å…ˆçº§é˜Ÿåˆ—
  async addJob(priority: 'high' | 'normal' | 'low', jobType: string, data: any, options?: any): Promise<void> {
    const queue = this.queues.get(priority);
    if (!queue) {
      throw new Error(`æœªæ‰¾åˆ°ä¼˜å…ˆçº§é˜Ÿåˆ—: ${priority}`);
    }

    await queue.add(jobType, data, options);
    this.logger.debug(`ä»»åŠ¡å·²æ·»åŠ åˆ° ${priority} ä¼˜å…ˆçº§é˜Ÿåˆ—: ${jobType}`);
  }

  // è·å–é˜Ÿåˆ—ç»Ÿè®¡ä¿¡æ¯
  async getQueueStats(): Promise<any> {
    const stats = {};

    for (const [name, queue] of this.queues) {
      const waiting = await queue.getWaiting();
      const active = await queue.getActive();
      const completed = await queue.getCompleted();
      const failed = await queue.getFailed();

      stats[name] = {
        waiting: waiting.length,
        active: active.length,
        completed: completed.length,
        failed: failed.length
      };
    }

    return stats;
  }
}
```

## ï¼ˆä¸‰ï¼‰ç›‘æ§ä¸å‘Šè­¦ç³»ç»Ÿ

**1. åº”ç”¨ç›‘æ§ä¸­é—´ä»¶**

```typescript
// server/src/middleware/monitoring.ts
import { Request, Response, NextFunction } from 'express';
import { Counter, Histogram, register } from 'prom-client';

// åˆ›å»ºç›‘æ§æŒ‡æ ‡
const httpRequestsTotal = new Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code']
});

const httpRequestDuration = new Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'route'],
  buckets: [0.1, 0.5, 1, 2, 5, 10]
});

const workflowExecutionsTotal = new Counter({
  name: 'workflow_executions_total',
  help: 'Total number of workflow executions',
  labelNames: ['status', 'workflow_id']
});

const nodeExecutionsTotal = new Counter({
  name: 'node_executions_total',
  help: 'Total number of node executions',
  labelNames: ['node_type', 'status']
});

const activeWorkflowInstances = new Counter({
  name: 'active_workflow_instances',
  help: 'Number of currently active workflow instances'
});

// HTTPè¯·æ±‚ç›‘æ§ä¸­é—´ä»¶
export const httpMetricsMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();

  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    const route = req.route?.path || req.path;

    httpRequestsTotal
      .labels(req.method, route, res.statusCode.toString())
      .inc();

    httpRequestDuration
      .labels(req.method, route)
      .observe(duration);
  });

  next();
};

// å·¥ä½œæµç¨‹ç›‘æ§
export class WorkflowMonitor {
  static recordExecution(workflowId: string, status: string): void {
    workflowExecutionsTotal
      .labels(status, workflowId)
      .inc();
  }

  static recordNodeExecution(nodeType: string, status: string): void {
    nodeExecutionsTotal
      .labels(nodeType, status)
      .inc();
  }

  static incrementActiveInstances(): void {
    activeWorkflowInstances.inc();
  }

  static decrementActiveInstances(): void {
    activeWorkflowInstances.inc(-1);
  }
}

// æŒ‡æ ‡å¯¼å‡ºç«¯ç‚¹
export const metricsHandler = (req: Request, res: Response) => {
  res.set('Content-Type', register.contentType);
  res.end(register.metrics());
};
```

**2. å¥åº·æ£€æŸ¥ç³»ç»Ÿ**

```typescript
// server/src/services/HealthChecker.ts
import mongoose from 'mongoose';
import Redis from 'ioredis';
import { Logger } from '../utils/logger';

interface HealthStatus {
  status: 'healthy' | 'unhealthy';
  timestamp: string;
  services: {
    database: ServiceStatus;
    redis: ServiceStatus;
    queue: ServiceStatus;
    external: ServiceStatus;
  };
  uptime: number;
  memory: {
    used: number;
    total: number;
    percentage: number;
  };
}

interface ServiceStatus {
  status: 'up' | 'down';
  responseTime?: number;
  error?: string;
}

export class HealthChecker {
  private redis: Redis;
  private logger: Logger;

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST || 'localhost',
      port: parseInt(process.env.REDIS_PORT || '6379'),
    });
    this.logger = new Logger('HealthChecker');
  }

  async getHealthStatus(): Promise<HealthStatus> {
    const startTime = Date.now();

    const [database, redis, queue, external] = await Promise.all([
      this.checkDatabase(),
      this.checkRedis(),
      this.checkQueue(),
      this.checkExternalServices()
    ]);

    const memory = process.memoryUsage();
    const memoryUsage = {
      used: Math.round(memory.heapUsed / 1024 / 1024),
      total: Math.round(memory.heapTotal / 1024 / 1024),
      percentage: Math.round((memory.heapUsed / memory.heapTotal) * 100)
    };

    const overallStatus = this.determineOverallStatus([database, redis, queue, external]);

    return {
      status: overallStatus,
      timestamp: new Date().toISOString(),
      services: {
        database,
        redis,
        queue,
        external
      },
      uptime: process.uptime(),
      memory: memoryUsage
    };
  }

  private async checkDatabase(): Promise<ServiceStatus> {
    try {
      const start = Date.now();
      await mongoose.connection.db.admin().ping();
      const responseTime = Date.now() - start;

      return {
        status: 'up',
        responseTime
      };
    } catch (error) {
      return {
        status: 'down',
        error: error.message
      };
    }
  }

  private async checkRedis(): Promise<ServiceStatus> {
    try {
      const start = Date.now();
      await this.redis.ping();
      const responseTime = Date.now() - start;

      return {
        status: 'up',
        responseTime
      };
    } catch (error) {
      return {
        status: 'down',
        error: error.message
      };
    }
  }

  private async checkQueue(): Promise<ServiceStatus> {
    try {
      // æ£€æŸ¥é˜Ÿåˆ—è¿æ¥çŠ¶æ€
      const queueInfo = await this.redis.info('server');

      return {
        status: queueInfo ? 'up' : 'down'
      };
    } catch (error) {
      return {
        status: 'down',
        error: error.message
      };
    }
  }

  private async checkExternalServices(): Promise<ServiceStatus> {
    try {
      // è¿™é‡Œå¯ä»¥æ£€æŸ¥å…³é”®çš„å¤–éƒ¨æœåŠ¡
      // ä¾‹å¦‚ï¼šSlack APIã€GitHub APIç­‰
      return {
        status: 'up'
      };
    } catch (error) {
      return {
        status: 'down',
        error: error.message
      };
    }
  }

  private determineOverallStatus(services: ServiceStatus[]): 'healthy' | 'unhealthy' {
    const criticalServices = services.slice(0, 3); // database, redis, queue
    const allCriticalUp = criticalServices.every(service => service.status === 'up');

    return allCriticalUp ? 'healthy' : 'unhealthy';
  }
}
```

# äº”ã€æ€»ç»“ä¸å±•æœ›

## ï¼ˆä¸€ï¼‰é¡¹ç›®æˆæœæ€»ç»“

é€šè¿‡æœ¬æ–‡çš„æ·±å…¥è§£æï¼Œæˆ‘ä»¬æˆåŠŸæ„å»ºäº†ä¸€ä¸ªå®Œæ•´çš„ä¼ä¸šçº§å·¥ä½œæµç¨‹æ„å»ºå™¨ç³»ç»Ÿï¼Œä¸»è¦æˆæœåŒ…æ‹¬ï¼š

**1. æŠ€æœ¯æ¶æ„æˆæœ**
- **å‰ç«¯å¯è§†åŒ–è®¾è®¡å™¨**ï¼šåŸºäºReact Flowå®ç°çš„æ‹–æ‹½å¼æµç¨‹è®¾è®¡ç•Œé¢ï¼Œæ”¯æŒå¤æ‚çš„èŠ‚ç‚¹è¿æ¥å’Œå®æ—¶é¢„è§ˆ
- **åç«¯æ‰§è¡Œå¼•æ“**ï¼šåŸºäºNode.jsçš„å¼‚æ­¥æ‰§è¡Œå¼•æ“ï¼Œæ”¯æŒå¹¶è¡Œå¤„ç†å’Œé”™è¯¯æ¢å¤
- **æ’ä»¶åŒ–èŠ‚ç‚¹ç³»ç»Ÿ**ï¼šå¯æ‰©å±•çš„èŠ‚ç‚¹æ³¨å†Œè¡¨ï¼Œæ”¯æŒè‡ªå®šä¹‰èŠ‚ç‚¹ç±»å‹å’Œç¬¬ä¸‰æ–¹é›†æˆ
- **ç»Ÿä¸€è¿æ¥å™¨æ¡†æ¶**ï¼šæ ‡å‡†åŒ–çš„ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆæ¥å£ï¼Œæ”¯æŒå¤šç§è®¤è¯æ–¹å¼

**2. æ ¸å¿ƒåŠŸèƒ½å®ç°**
- **å¯è§†åŒ–æµç¨‹è®¾è®¡**ï¼šç›´è§‚çš„æ‹–æ‹½ç•Œé¢ï¼Œæ”¯æŒå¤æ‚çš„åˆ†æ”¯å’Œå¾ªç¯é€»è¾‘
- **å®æ—¶æ‰§è¡Œç›‘æ§**ï¼šWebSocketå®æ—¶é€šä¿¡ï¼Œæä¾›æ‰§è¡ŒçŠ¶æ€çš„å³æ—¶åé¦ˆ
- **é”™è¯¯å¤„ç†æœºåˆ¶**ï¼šå®Œå–„çš„é”™è¯¯æ•è·ã€é‡è¯•å’Œæ¢å¤ç­–ç•¥
- **æ€§èƒ½ä¼˜åŒ–**ï¼šå¤šçº§ç¼“å­˜ã€ä»»åŠ¡é˜Ÿåˆ—å’Œæ•°æ®åº“ç´¢å¼•ä¼˜åŒ–

**3. ä¼ä¸šçº§ç‰¹æ€§**
- **å®‰å…¨æ€§**ï¼šæ•°æ®åŠ å¯†ã€è®¤è¯æˆæƒå’Œè®¿é—®æ§åˆ¶
- **å¯æ‰©å±•æ€§**ï¼šå¾®æœåŠ¡æ¶æ„ã€å®¹å™¨åŒ–éƒ¨ç½²å’Œæ°´å¹³æ‰©å±•
- **ç›‘æ§å‘Šè­¦**ï¼šå…¨é¢çš„åº”ç”¨ç›‘æ§å’Œå¥åº·æ£€æŸ¥ç³»ç»Ÿ
- **é«˜å¯ç”¨æ€§**ï¼šæ•…éšœè½¬ç§»ã€è´Ÿè½½å‡è¡¡å’Œæ•°æ®å¤‡ä»½

## ï¼ˆäºŒï¼‰æŠ€æœ¯éš¾ç‚¹ä¸è§£å†³æ–¹æ¡ˆ

**1. å¤æ‚æµç¨‹æ‰§è¡Œçš„æŒ‘æˆ˜**
- **é—®é¢˜**ï¼šå¦‚ä½•å¤„ç†åŒ…å«åˆ†æ”¯ã€å¾ªç¯å’Œå¹¶è¡Œæ‰§è¡Œçš„å¤æ‚å·¥ä½œæµç¨‹
- **è§£å†³æ–¹æ¡ˆ**ï¼šåŸºäºæœ‰å‘æ— ç¯å›¾çš„æ‰§è¡Œå¼•æ“ï¼Œä½¿ç”¨æ‹“æ‰‘æ’åºç®—æ³•ç¡®å®šæ‰§è¡Œé¡ºåºï¼Œé€šè¿‡ä»»åŠ¡é˜Ÿåˆ—å®ç°å¼‚æ­¥å¹¶è¡Œå¤„ç†

**2. ç¬¬ä¸‰æ–¹æœåŠ¡é›†æˆçš„å¤æ‚æ€§**
- **é—®é¢˜**ï¼šä¸åŒæœåŠ¡çš„APIæ ¼å¼ã€è®¤è¯æ–¹å¼å’Œé”™è¯¯å¤„ç†æœºåˆ¶å·®å¼‚å¾ˆå¤§
- **è§£å†³æ–¹æ¡ˆ**ï¼šè®¾è®¡ç»Ÿä¸€çš„è¿æ¥å™¨æ¥å£ï¼Œæ ‡å‡†åŒ–æ•°æ®æ ¼å¼è½¬æ¢ï¼Œå®ç°å¯æ’æ‹”çš„è®¤è¯ç­–ç•¥

**3. å®æ—¶çŠ¶æ€åŒæ­¥çš„æŠ€æœ¯æŒ‘æˆ˜**
- **é—®é¢˜**ï¼šå¦‚ä½•åœ¨åˆ†å¸ƒå¼ç¯å¢ƒä¸­å®æ—¶åŒæ­¥å·¥ä½œæµç¨‹æ‰§è¡ŒçŠ¶æ€
- **è§£å†³æ–¹æ¡ˆ**ï¼šåŸºäºSocket.ioçš„å®æ—¶é€šä¿¡ï¼Œç»“åˆRediså‘å¸ƒè®¢é˜…æœºåˆ¶ï¼Œç¡®ä¿çŠ¶æ€æ›´æ–°çš„åŠæ—¶æ€§å’Œä¸€è‡´æ€§

## ï¼ˆä¸‰ï¼‰æœªæ¥å‘å±•æ–¹å‘

**1. AIæ™ºèƒ½åŒ–å¢å¼º**
- **æ™ºèƒ½æµç¨‹æ¨è**ï¼šåŸºäºæœºå™¨å­¦ä¹ åˆ†æç”¨æˆ·è¡Œä¸ºï¼Œæ¨èæœ€ä¼˜çš„æµç¨‹è®¾è®¡æ¨¡å¼
- **è‡ªåŠ¨é”™è¯¯è¯Šæ–­**ï¼šAIé©±åŠ¨çš„é”™è¯¯åˆ†æå’Œä¿®å¤å»ºè®®ç³»ç»Ÿ
- **è‡ªç„¶è¯­è¨€å¤„ç†**ï¼šæ”¯æŒè‡ªç„¶è¯­è¨€æè¿°è½¬æ¢ä¸ºå¯è§†åŒ–å·¥ä½œæµç¨‹

**2. ä¼ä¸šçº§åŠŸèƒ½æ‰©å±•**
- **ç»†ç²’åº¦æƒé™æ§åˆ¶**ï¼šåŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶å’Œå®¡æ‰¹æµç¨‹
- **ç‰ˆæœ¬ç®¡ç†ç³»ç»Ÿ**ï¼šå·¥ä½œæµç¨‹çš„ç‰ˆæœ¬æ§åˆ¶ã€åˆ†æ”¯ç®¡ç†å’Œå›æ»šåŠŸèƒ½
- **åˆè§„æ€§æ”¯æŒ**ï¼šæ»¡è¶³GDPRã€SOXç­‰æ³•è§„è¦æ±‚çš„å®¡è®¡æ—¥å¿—å’Œæ•°æ®ä¿æŠ¤

**3. ç”Ÿæ€ç³»ç»Ÿå»ºè®¾**
- **å¼€æ”¾APIå¹³å°**ï¼šæä¾›å®Œæ•´çš„REST APIå’ŒSDKï¼Œæ”¯æŒç¬¬ä¸‰æ–¹å¼€å‘
- **æ’ä»¶å¸‚åœº**ï¼šå¼€æ”¾çš„æ’ä»¶ç”Ÿæ€ç³»ç»Ÿï¼Œæ”¯æŒç¤¾åŒºè´¡çŒ®å’Œå•†ä¸šæ’ä»¶
- **æ¨¡æ¿åº“**ï¼šä¸°å¯Œçš„è¡Œä¸šæ¨¡æ¿å’Œæœ€ä½³å®è·µåˆ†äº«å¹³å°

**4. æŠ€æœ¯æ¼”è¿›æ–¹å‘**
- **è¾¹ç¼˜è®¡ç®—æ”¯æŒ**ï¼šæ”¯æŒåœ¨è¾¹ç¼˜è®¾å¤‡ä¸Šæ‰§è¡Œè½»é‡çº§å·¥ä½œæµç¨‹
- **åŒºå—é“¾é›†æˆ**ï¼šåˆ©ç”¨åŒºå—é“¾æŠ€æœ¯ç¡®ä¿å·¥ä½œæµç¨‹æ‰§è¡Œçš„ä¸å¯ç¯¡æ”¹æ€§
- **é‡å­è®¡ç®—å‡†å¤‡**ï¼šä¸ºæœªæ¥çš„é‡å­è®¡ç®—ç¯å¢ƒè®¾è®¡å…¼å®¹çš„æ¶æ„

## ï¼ˆå››ï¼‰æœ€ä½³å®è·µå»ºè®®

**1. è®¾è®¡åŸåˆ™**
- **æ¨¡å—åŒ–è®¾è®¡**ï¼šä¿æŒç»„ä»¶çš„ç‹¬ç«‹æ€§å’Œå¯é‡ç”¨æ€§
- **é”™è¯¯ä¼˜å…ˆ**ï¼šå§‹ç»ˆè€ƒè™‘é”™è¯¯æƒ…å†µå’Œå¼‚å¸¸å¤„ç†
- **æ€§èƒ½æ„è¯†**ï¼šåœ¨è®¾è®¡é˜¶æ®µå°±è€ƒè™‘æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**2. å¼€å‘å»ºè®®**
- **æµ‹è¯•é©±åŠ¨**ï¼šç¼–å†™å…¨é¢çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
- **æ–‡æ¡£å®Œå–„**ï¼šç»´æŠ¤è¯¦ç»†çš„APIæ–‡æ¡£å’Œç”¨æˆ·æŒ‡å—
- **ä»£ç è´¨é‡**ï¼šä½¿ç”¨ä»£ç æ£€æŸ¥å·¥å…·å’ŒæŒç»­é›†æˆæµç¨‹

**3. è¿ç»´å»ºè®®**
- **ç›‘æ§å®Œå–„**ï¼šå»ºç«‹å…¨é¢çš„ç›‘æ§å’Œå‘Šè­¦ä½“ç³»
- **å¤‡ä»½ç­–ç•¥**ï¼šåˆ¶å®šå®Œå–„çš„æ•°æ®å¤‡ä»½å’Œæ¢å¤è®¡åˆ’
- **å®‰å…¨æ›´æ–°**ï¼šå®šæœŸæ›´æ–°ä¾èµ–åŒ…å’Œå®‰å…¨è¡¥ä¸

å·¥ä½œæµç¨‹æ„å»ºå™¨ä½œä¸ºä¼ä¸šæ•°å­—åŒ–è½¬å‹çš„é‡è¦å·¥å…·ï¼Œå°†åœ¨æœªæ¥çš„è‡ªåŠ¨åŒ–æµªæ½®ä¸­å‘æŒ¥è¶Šæ¥è¶Šé‡è¦çš„ä½œç”¨ã€‚é€šè¿‡æœ¬æ–‡çš„å®æˆ˜é¡¹ç›®ï¼Œæˆ‘ä»¬ä¸ä»…æŒæ¡äº†æ ¸å¿ƒæŠ€æœ¯å®ç°ï¼Œæ›´é‡è¦çš„æ˜¯ç†è§£äº†ç³»ç»Ÿè®¾è®¡çš„æ€è·¯å’Œæ–¹æ³•ï¼Œä¸ºæ„å»ºæ›´åŠ æ™ºèƒ½ã€é«˜æ•ˆçš„è‡ªåŠ¨åŒ–å¹³å°å¥ å®šäº†åšå®çš„åŸºç¡€ã€‚

---

## å‚è€ƒèµ„æ–™

- [React Flowå®˜æ–¹æ–‡æ¡£](https://reactflow.dev/) - å¯è§†åŒ–æµç¨‹å›¾åº“çš„å®Œæ•´æŒ‡å—
- [Bullé˜Ÿåˆ—ç³»ç»Ÿ](https://github.com/OptimalBits/bull) - Redisä»»åŠ¡é˜Ÿåˆ—çš„æœ€ä½³å®è·µ
- [MongoDBå®˜æ–¹æ–‡æ¡£](https://docs.mongodb.com/) - æ–‡æ¡£æ•°æ®åº“è®¾è®¡å’Œä¼˜åŒ–
- [Slack APIæ–‡æ¡£](https://api.slack.com/) - Slacké›†æˆå¼€å‘æŒ‡å—
- [GitHub APIæ–‡æ¡£](https://docs.github.com/en/rest) - GitHubé›†æˆå¼€å‘å‚è€ƒ
- [Socket.ioå®æ—¶é€šä¿¡](https://socket.io/) - å®æ—¶åŒå‘é€šä¿¡è§£å†³æ–¹æ¡ˆ
- [Dockerå®˜æ–¹æ–‡æ¡£](https://docs.docker.com/) - å®¹å™¨åŒ–éƒ¨ç½²æœ€ä½³å®è·µ
- [Prometheusç›‘æ§](https://prometheus.io/) - åº”ç”¨ç›‘æ§å’Œå‘Šè­¦ç³»ç»Ÿ
- [Node.jsæœ€ä½³å®è·µ](https://github.com/goldbergyoni/nodebestpractices) - Node.jså¼€å‘æŒ‡å—
